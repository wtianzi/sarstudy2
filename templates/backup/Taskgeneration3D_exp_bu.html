<!DOCTYPE html>
{% load static %}
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>SAR MAPPING DEMO</title>
  <link rel="stylesheet" href="https://js.arcgis.com/4.12/esri/themes/light/main.css"/>

  <script src="{% static 'js/d3.v4.min.js' %}"></script>
  <script src="{% static 'js/d3-polygon-clip.js' %}"></script>

  <script src="https://js.arcgis.com/4.22/"></script>
  <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
  <script src="{% static 'js/jquery.csv.js' %}"></script>
  <script src="{% static 'js/sarfunctions.js' %}"></script>
  <link rel="stylesheet" type="text/css" href="{% static 'css/taskgeneration.css' %}"  />
  <script type="text/javascript" src="{% static 'data/scenario_3d.js' %}"></script>
  <script type="text/javascript" src="{% static 'esritoken.js' %}"></script>
  <style>
  html,
  body,

  #viewDiv3D {
    padding: 0;
    margin: 0;
    width: 100%;
    height: 100%;
  }
  #viewDiv2D {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 45%;
  }
  .bottom_screen{
    bottom: 30px;
    left: 30%;
    position: absolute;
  }
  .bt_screen {
    background: white;
    padding: 9px;
    border: 1px solid #005e95;
    margin: 5px;
    color: #005e95;
    margin-left: 10px;
    cursor: pointer;
  }
  .bt_screen:hover,
  .bt_screen:focus {
    background-color: #e4e4e4;
  }
  .lb_screen{
    background: white;
    padding: 9px;
    border: 1px solid #f0f5f5;
    margin: 5px;
    color: #808080;
    margin-left: 10px;
    cursor: pointer;
  }
  #showtarget{
      padding: 5px;
  }
  #myRangeTrust{
    width: 80%;
  }
  #clueConfirm{
    width: 90%;
  }
  #map2Dvs3D{
    padding: 1px;
  }
  #bt_scenario{
    width: 90%;
  }
  #q_scene{
    width: 90%;
  }
  #testImg{
    display: block;
    margin-left: auto;
    margin-right: auto;
  }
  .btnx {
    border: none;
    background-color: inherit;
    padding: 14px 28px;
    font-size: 16px;
    cursor: pointer;
    display: inline-block;
  }
  .btnx:hover {background: #eee;}
  .x2d {color: dodgerblue;}
  .x3d {color: black;}

  ::-webkit-scrollbar {
  width: 10px;
  }

  /* Track */
  ::-webkit-scrollbar-track {
    background: #f1f1f1;
  }

  /* Handle */
  ::-webkit-scrollbar-thumb {
    background: #888;
  }

  /* Handle on hover */
  ::-webkit-scrollbar-thumb:hover {
    background: #555;
  }
  </style>
  <script>

//https://developers.arcgis.com/javascript/latest/sample-code/sketch-geometries/index.html
//https://developers.arcgis.com/javascript/latest/sample-code/sandbox/index.html?sample=sketch-update-validation
    require([
      "esri/widgets/Sketch/SketchViewModel",
      "esri/Graphic",
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/FeatureLayer",
      "esri/layers/GraphicsLayer",
      "esri/geometry/Polygon",
      "esri/geometry/geometryEngine",
      "esri/widgets/Expand",
      "esri/layers/TileLayer",
      "esri/widgets/BasemapToggle",//-----------------------------
      "esri/views/2d/draw/Draw",
      "esri/widgets/CoordinateConversion",//,      "esri/widgets/Sketch"
      "esri/widgets/DistanceMeasurement2D",
      "esri/widgets/AreaMeasurement2D",
      "esri/geometry/Extent",
      "esri/geometry/Point",
      "esri/layers/OpenStreetMapLayer",
      "esri/widgets/Track",
      "esri/widgets/Search",
      "esri/geometry/Multipoint",
      "esri/layers/ElevationLayer",
      "esri/geometry/Polyline",
      "esri/geometry/Circle",
      "esri/layers/GeoJSONLayer",
      "esri/core/promiseUtils",
      "esri/views/SceneView",
      "esri/symbols/LineSymbol3DLayer",
      "esri/symbols/LineSymbol3D",
      "esri/config",
      "esri/geometry/SpatialReference",
      "esri/geometry/projection",
      "esri/layers/WMSLayer"
    ], function(
      SketchViewModel, Graphic, Map, MapView, FeatureLayer,
      GraphicsLayer, Polygon, geometryEngine, Expand, TileLayer,BasemapToggle,
      Draw,CoordinateConversion,
      DistanceMeasurement2D,AreaMeasurement2D,Extent,Point,
      OpenStreetMapLayer,Track,Search,Multipoint,
      ElevationLayer,Polyline,Circle,GeoJSONLayer,promiseUtils,
      SceneView,LineSymbol3DLayer,LineSymbol3D,esriConfig,
      SpatialReference,projection,
      WMSLayer
    ) {
      // http://127.0.0.1:8000/experiment/task3D/1669404456167/0/
      esriConfig.apiKey = esritoken.esritoken;
      //console.log(g_experiment);
      let m_expsetupobj=g_experiment;
      var participant_avata={
        "participant_id":0,
        'experimentsetup_index':0,
        "experimentsetup":0,
        'experimentindex':0
      }
      var m_exp_loc_index=m_expsetupobj.experimentsetup[participant_avata.experimentsetup].loc;
      //console.log(m_exp_loc_index);
      var m_exp_visualizationtype_index=m_expsetupobj.experimentsetup[participant_avata.experimentsetup].vt;
      var m_exp_location=m_expsetupobj.location_3D[m_exp_loc_index];

      let m_exp_variables={
        hour:11
      };
      var m_selectedgraphicrect2D=null;//updated every click

      var m_UAVRouteHML=[];
      var m_currentHeight=0;//0,1,2:h,m,l // for path planning
      var m_passPath=[];//points
      var m_step=0;
      var m_segmentRingColor={'H':[0, 156, 156],'M':[156, 156, 0],'L':[255, 156, 0],'B':[255, 255, 0]};
      var m_clueOnVertical3D=[];//clue at different height
      var m_clueOnVertical3DOffset=0;// index m_clueOnVertical3D, from high to low:0,1,2,3// for uav inspection
      var m_DroneUpdate3D=true;
      var m_searchFinish=false;
      var m_unfoundClues=[];
      var m_currentClue;//=[0,0,0,0];//
      var m_slice_tag=true;
      var m_geometry_2D;
      var m_urlObj;
      //block participant judegement
      var m_expResults={"BPJudge":[]};
      var m_trialindex=0;
      var m_height_3D=[100,200,300];
      //var m_camera_x_offset=0.010431;
      //var m_camera_y_offset=-0.0099479;
      // ic 4
      var m_camera_x_offset=-0.0178218478785368;//m_expsetupobj.location_3D.camera_x_offset
      var m_camera_y_offset=-0.0064792486895441925;//m_expsetupobj.location_3D.camera_y_offset

      let view, sketchViewModel, draw,newDevelopmentGraphic,instructionsExpand,coordinateLayer;
      let view3D;
      let intersects = false;
      let contains = true;
      let updated_polygonring=[];
      let width=1600*1.5;
      let height=900*1.5;
      let m_d=new Date();
      let scale=14;//14
      let m_experimentres={
        "scenario":null,
        "lostpersontype":null,
        "traildatacenter":null,
        "participantid":null,
        "participant_index":(m_d.getMonth()+1).toString()+m_d.getDate().toString()+m_d.getHours().toString(),
        "teamnumber":5,
        "taskid":m_d.getHours().toString()+m_d.getMinutes().toString()+m_d.getSeconds().toString(),
        "taskstart":Date.now(),
        "taskstop":null,
        "taskduration":100,
        "targetcellindex":0,
        "polygonnumbers":0,
        "stophour":0,
        "visualization_type":"probability",
        "step_number":0,
        "step_details":[],//visualresponsetime: time between (the heatmap is loaded) and (active the first team icon)
        "actions":[],//#id and timestamp, {"id":"btn...","timestamp": Date.now(), "description":"click button generate task"}
        "allpolygons":null,
        "mapscale":scale,
        "totaltaskround":5 // after 5 rounds of try, the task will be complet
      };
      let m_scenario_index=0;
      let m_lostpersontype_index=0;
      let m_scenarios=[
        {"scenario_index":0,"scenario_name":"ic1","center":[-80.4757389347337, 37.2040570285143]}, //[-80.4757389347337, 37.2040570285143]//-80.5460, 37.2041
        {"scenario_index":1,"scenario_name":"ic2","center":[-80.5450562640660, 37.1977538769385]},//[-80.5450562640660, 37.1977538769385]//-80.4757, 37.2041
        {"scenario_index":2,"scenario_name":"ic3","center":[-80.5451, 37.1978]}
      ];
      let m_lostpersontype=[
        {"lostperson_index":0,"lostperson_type":"child"},
        {"lostperson_index":1,"lostperson_type":"dementia"},
        {"lostperson_index":2,"lostperson_type":"hiker"}
      ];

      // this will be changed after the data is loaded
      let m_targetandclues={
        "target":[-80.476, 37.20],
        "clue":[{"clue_index":0,"status":"unfound","info":"cloth","data":[-80.46, 37.205],'photoid':1},
                          {"clue_index":1,"status":"unfound","info":"drink","data":[-80.47, 37.20],'photoid':2}]
      };
      let m_scenarios_rings={'child10to12':[800,1600,3200,9000],
      'dementia':[300,800,1900,8300],
      'hiker':[1100,3100,5800,18300]};

      let m_exp_order=0;

      let gcx=-80.556451;
      let gcy=37.2;

      let gwidth=10;
      let gheight=10;
      let voronoistyle="random";
      let glvertices;
      let glverticeslist=[];
      let maxdistanceerror = 0.0001;

      let eacharea=10000000;//500000//240000;//60 acer;
      let activeWidget = null;

      let allpolygons=[];
      let allpolygons_text=[];
      let activepolygonset=[];
      let activepolygonpoints=[];
      let move_polygon;
      let area_extent;

      let timerid1,timerid3;
      let timerid3d;
      let arr_featureset=[];
      let waypointstartpointarray=[];

      let m_colorgroup={};// store color of symbols for gps and pathplaning
      let validSymbol;

      let m_filterprob=0.0000001;
      let m_lpdata_con=[];
      let m_lpdata_trajectory=[];
      let m_lpdata_tra_colormap=[];

      let m_lpdata_trial=[];
      let m_colormap=0;//0: rainbow, 1: yellow-red, 2: blue-red
      let t_rgb=[];
      let m_editing=false;
      let m_visualizationtype='byhour';// or 'byclue' if any clue is found

      //let m_searchedarea=[];//all polygon marked gray
      let m_lptrail_pts=[];//the target person location at hour index
      let m_targetpolygon;
      let m_taskpolygon={};

      let epsg4326_voronoiarr=[];


      const graphicInitLayer= new GraphicsLayer();
      const graphicsLayer = new GraphicsLayer({
        opacity:0.6//0.6
      });

      const pathplanninggraphicsLayer = new GraphicsLayer({
        opacity:0.5
      });

      const visualization_Contourmap_Layer = new GraphicsLayer({
        opacity:0.8
      });

      const visualization_Segmentheat_Layer = new GraphicsLayer({
        opacity:0.5
      });

      const visualization_Trajectories_Layer = new GraphicsLayer({
        opacity:0.9//0.5
      });

      const visualization_Cone_Layer = new GraphicsLayer({
        opacity:0.5
      });

      const graphicInteractionLayer =new GraphicsLayer();

      const temperalgraphicLayer = new GraphicsLayer();

      const graphicLayer_hit_2D = new GraphicsLayer();


      let elevLyr = new ElevationLayer({
        // Custom elevation service
        url: "//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer/"//"https://sampleserver6.arcgisonline.com/arcgis/rest/services/Elevation/MtBaldy_Elevation/ImageServer"
      });

      // reference: https://developers.google.com/earth-engine/datasets/catalog/USGS_NLCD_RELEASES_2016_REL#description
      // NLCD: https://www.mrlc.gov/data-services-page

      // https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/ows?SERVICE=WMS
      // url: "https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms",
      //url: "https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/ows?SERVICE=WMS",

      const landcoverlayer = new WMSLayer({
          url: "https://www.mrlc.gov/geoserver/mrlc_display/ows",
          sublayers: [
            {
              name: "NLCD_2019_Land_Cover_L48"
            }
          ]
      });

      const landcoverlayer2 = new WMSLayer({
         url: "https://www.mrlc.gov/geoserver/mrlc_display/NLCD_2019_Land_Cover_L48/wms",
         opacity:0.5
       });

      const map = new Map({
        basemap: "hybrid",//"hybrid",//"satellite",
        //ground: "world-elevation",
        layers: [
          landcoverlayer,
          visualization_Contourmap_Layer,//
          visualization_Segmentheat_Layer,
          graphicsLayer,//
          pathplanninggraphicsLayer,
          graphicInitLayer,//
          visualization_Trajectories_Layer,//
          graphicInteractionLayer,//
          temperalgraphicLayer,// temperal layer include target
          visualization_Cone_Layer,//
          graphicLayer_hit_2D
        ]
      });

      setUpView();

      // UAV path
      const graphicsLayer3D = new GraphicsLayer({
        // elevation information: https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-GraphicsLayer.html#elevationInfo
        elevationInfo: {
          mode: "relative-to-ground",
          offset: 10
        }
      });

      const graphicsLayer3D_UAVPath = new GraphicsLayer({
        // elevation information: https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-GraphicsLayer.html#elevationInfo
        elevationInfo: {
          mode: "relative-to-ground",
          offset: 10
        }
      });

      // hiking example : https://developers.arcgis.com/javascript/latest/sample-code/sandbox/?sample=visualization-line-patterns
      // segmented cells
      const gridsLayer3D = new GraphicsLayer({
        // elevation information: https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-GraphicsLayer.html#elevationInfo
        elevationInfo: {
          mode: "on-the-ground"
        }
      });

      // UAV 3D icon
      const graphicsLayer3D_point = new GraphicsLayer({
        elevationInfo: {
          mode: "relative-to-ground",
          offset: 10
        }
      });

      // selected cell
      const graphicLayer_hit_3D = new GraphicsLayer({
        elevationInfo: {
          mode: "on-the-ground",
          offset: 20
        }
      });

      // contour map
      const graphicLayer_contour_3D = new GraphicsLayer({
        opacity:0.5,
        elevationInfo: {
          mode: "on-the-ground",
          offset: 15
        }
      });
      const graphicLayer_clue_3D = new GraphicsLayer({
        elevationInfo: {
          mode: "relative-to-ground",
          offset: 10
        }
      });

      const graphicLayer_heightline_3D = new GraphicsLayer({
        elevationInfo: {
          mode: "relative-to-ground",
          offset: 10
        }
      });

      setupView3D();
      // creates new view and map, adds featurelayers and graphicslayer to the view

      // This function is called when a user clicks on the view.
      function setUpGraphicClickHandler() {
        view.on("click", function(event) {
          //console.log("click");

          //elevation=============
          let position = event.mapPoint;
          //console.log(position);
          let queryBeforeLandslide = elevLyr.queryElevation(
            position
          );

          promiseUtils
            .eachAlways([queryBeforeLandslide])
            .then(function(results) {
              $("#elevation").text("Elenvation: "+results[0].value.geometry.z);
            });

          // check if the sketch's state active if it is then that means
          // the graphic is already being updated, no action required.
          if (sketchViewModel.state === "active") {
            //testing forbid mover
            return;
          }

          view.hitTest(event).then(function(response) {
            let results = response.results;
            // Check if the new development graphic was clicked and pass
            // the graphic to sketchViewModel.update() with reshape tool.
            results.forEach(function(result) {
              if(result.graphic!=null){
                if(result.graphic.attributes!=null){
                  $("#cellname").val("S"+result.graphic.attributes.cellindex);
                  if(m_editing){
                    //console.log("here2");
                    if (result.graphic.layer === sketchViewModel.layer) {
                      sketchViewModel.update([result.graphic], {
                        tool: "reshape"//"reshape"
                      });
                    }
                  }

                  if(result.graphic!= null){
                    m_selectedgraphicrect2D=result.graphic;
                    //console.log(m_selectedgraphicrect2D);
                    DrawCell2D(result.graphic);
                    DrawCell3D(result.graphic);
                  }
                }

              }
            });
          });
        });

      }
      setUpGraphicClickHandler();

      view.when(function() {
        area_extent=view.extent;


        // Query all buffer features from the school buffers featurelayer

        // Create a new instance of sketchViewModel and set its required properties

        sketchViewModel = new SketchViewModel({
          view: view,
          layer: graphicsLayer,
          updateOnGraphicClick: false,
          defaultUpdateOptions: { // set the default options for the update operations
            //tool: "transform",
            toggleToolOnClick: false//false // only reshape operation will be enabled
          }
        })

        activepolygonset=[];
        // Listen to sketchViewModel's update event to do
        // graphic reshape or move validation
        sketchViewModel.on(["update", "undo", "redo"], onGraphicUpdate);
      });


      function addVoronoi(){
        let textend;
        let wholearea;
        if(activeWidget){
          textent=activeWidget.viewModel.measurement.geometry.extent;
          wholearea=activeWidget.viewModel.measurement.area;
        }
        else{
          let jsonextent=view.extent.toJSON();
          textent=Extent.fromJSON(jsonextent);
          let ori_xmin=textent.xmin;
          let ori_wid=textent.width*0.01;
          textent=textent.expand(0.8);
          let centerpoint = textent.center.clone();
          centerpoint.x= textent.center.x;//+(textent.xmin-ori_xmin-ori_wid);
          textent=textent.centerAt(centerpoint);
          area_extent=textent;
          wholearea=geometryEngine.planarArea(Polygon.fromExtent(textent));
        }
        let npoints=2*Math.round(wholearea/eacharea+0.5);      //wholearea=wholetask.area;//metric   240  : acre  60
        let lbx=textent.xmin,
            lby=textent.ymin,
            rtx=textent.xmax,
            rty=textent.ymax;
            gwidth=textent.width;
            gheight=textent.height;

        let sites = d3.range(npoints)//15
                   .map(function(d) { return [Math.random() * gwidth+lbx, Math.random() * gheight+lby]; });
        let in_point=new Point({
          x:textent.center.x+ 0.1*(Math.random()-0.5)*textent.width,
          y:textent.center.y+ 0.1*(Math.random()-0.5)*textent.height,
          spatialReference:view.spatialReference
        });
        //sites = GetSitesFromN(npoints,in_point,textent);
        sites = GetSites(npoints,textent);
        let voronoi = d3.voronoi().extent([[lbx,lby], [rtx,rty]]);
        let diagram = voronoi(sites),
            links = diagram.links(),
            vpolygons = diagram.polygons();


        if(activeWidget){
          //console.log(activeWidget);
          vpolygons=ClipPolygongsByPoints(vpolygons,activeWidget.viewModel.measurement.geometry.rings[0].slice(0,activeWidget.viewModel.measurement.geometry.rings[0].length-1));
        }
        //console.log(vpolygons);
        ClearAll();
        addGraphics(vpolygons);
        addGraphics3D(vpolygons);
      }

      function ClipPolygongsByPoints(vpolygons,points){
        let cpy=[];
        for(let i=0;i<vpolygons.length;i++){
          let temp=d3.polygonClip(vpolygons[i],polygonClone(points.reverse()));
          if(temp.length>0){ cpy.push(temp); }
        }
        return cpy;
      }
      function GetSites(n,t_extent){
        let res_points=[];
        //center point [0,0]
        //first round radius:1, second:2,third:3
        let t_incrementalradius=1;//default is 1, for 3D 0.5
        let t_radius=1;
        let t_firstround=3;

        //second round
        let res_count=0;
        let t_wholearea=0;
        let t_cellarea=t_radius*t_radius/t_firstround;

        while(n>res_count){
          let t_roundarea=t_radius*t_radius-t_wholearea;
          let t_celldegree=t_cellarea/t_roundarea;
          let t_totaldegree=0;
          while(t_totaldegree<=0.99){
            res_points.push([(t_radius-0.5)*Math.sin(2*Math.PI*t_totaldegree),(t_radius-0.5)*Math.cos(2*Math.PI*t_totaldegree)]);
            t_totaldegree=t_totaldegree+t_celldegree;
            res_count=res_count+1;
          }
          t_wholearea=t_radius*t_radius;
          t_radius=t_radius+t_incrementalradius;
        }

        //standrized from 1:1 into width and height ratio
        t_radius=t_radius-t_incrementalradius;
        let t_wscale=t_extent.width/(2*t_radius);
        let t_hscale=t_extent.height/(2*t_radius);

        for(let i=0;i<res_count;i++){
          res_points[i][0]=res_points[i][0]*t_wscale+t_extent.center.x;
          res_points[i][1]=res_points[i][1]*t_hscale+t_extent.center.y;
        }
        return res_points;
      }
      function GetSitesFromN(n,in_point,t_extent){
        let t_portion=gwidth/gheight;
        //n points
        let res_points=[];
        let t_poly=Polygon.fromExtent(t_extent);
        //in_point=t_poly.centroid;
        //calculate the shortiest distance from edge to
        //----pass
        //get the nearest point on t_poly from in_point
        let res_nearst=0.5*Math.min(t_extent.width,t_extent.height);
        //let res_nearst=geometryEngine.nearestVertex(t_poly,in_point,"meters").distance;
        //nearestpoint.coordinate;
        //nearestpoint.distance;
        res_i=[];
        for (let i=4;i<9;i++){
          let j=0, m=0;
          while(m<=n){
            m=m+i*Math.pow(2,j);
            j=j+1;
          }
          let t_x=n+i*2^j-m;
          if(t_x<2 && j>1){
            res_i.push([j-1,i,i*2^(j-1)+1]);
          }
          else{
            res_i.push([j,i,t_x]);//[j circles, m-n the outer ring number]
          }
        }
        let t_arr=res_i.pop();
        while(t_arr[0]<=1 && res_i.length>0){
          t_arr=res_i.pop();
        }
        let t_root=0;
        let arr_root=[];
        for(let i=0;i<t_arr[0];i++){
          t_root+=Math.pow(2,i);
          arr_root.push(t_root);
        }
        let r=res_nearst/Math.sqrt(t_root);
        // r, a, r+a
        let t_area=Math.pow(r,2);// the area of central circle
        let s_area=0;
        let t_pre_r=0;
        let ncount=0;
        for (let i=0;i<t_arr[0]-1;i++){
          s_area=t_area*arr_root[i];
          let t_ra=Math.sqrt(s_area);//
          //draw points
          let t_r=0.5*(t_ra+t_pre_r);//t_portion*t_pre_r
          let k=2*Math.PI/(t_arr[1]*Math.pow(2,i)); // radin of each circle
          for(let j=0;j<t_arr[1]*Math.pow(2,i);j++){
            res_points.push([in_point.x+t_portion*t_r*Math.cos(j*k),in_point.y+t_r*Math.sin(j*k)]);
            ncount+=1;
          }
          t_pre_r=t_ra;
        }
        let t_ra=res_nearst;
        //draw points
        let t_r=0.5*(t_ra+t_pre_r);
        let k=2*Math.PI/(t_arr[2]);
        for(let j=0;j<t_arr[2];j++){
          res_points.push([in_point.x+t_portion*t_r*Math.cos(j*k),in_point.y+t_r*Math.sin(j*k)]);
          ncount+=1;
        }
        if(0){
          res_points=d3.range(n)//15
                     .map(function(d) { return [Math.random() * t_extent.width+t_extent.xmin, Math.random() * t_extent.height+t_extent.ymin]; });
        }
        return res_points;
      }

      function SaveExperimentdatatoDB(tobj={}){
          tobj["ts"]=Date.now();
          let URL = "{% url 'updateexperimentdata' %}";
          let data = {
                 csrfmiddlewaretoken: '{{ csrf_token }}',
                 'resarr': JSON.stringify(tobj)
                };
          $.post(URL, data, function(response){
           let res=JSON.parse(response);
             if(res.flag == 'success'){
               //console.log(res);
              }
             else{ alert(response); }
          });
      }
      function addFreedraw(){
        let action = draw.create("polygon");
        // focus the view to activate keyboard shortcuts for drawing polygons
        view.focus();

        // listen polygonDrawAction events to give immediate visual feedback
        // to users as the polygon is being drawn on the view.
        action.on("vertex-add", drawPolygon);
        action.on("cursor-update", drawPolygon);
        action.on("vertex-remove", drawPolygon);
        action.on("redo", drawPolygon);
        action.on("undo", drawPolygon);
        action.on("draw-complete", drawPolygon);
      }

      function addGraphics(vtriangles) {
        // transfer the voronoi polygon:vpolygons to gispolygon
        //validSymbol = createSymbol([0, 170, 255, 0.4], "solid", 2, [255,255, 255]);
        let text_symbol = {
          type: "text",  // autocasts as new TextSymbol()
          color: "white",
          haloColor: "black",
          haloSize: "1px",
          text: "You are here",
          xoffset: 3,
          yoffset: 3,
          font: {  // autocast as new Font()
            size: 12,
            family: "Josefin Slab",
            weight: "bold"
          }
        };
        for (let i=0;i<vtriangles.length;i++){
          vtriangles[i].push(vtriangles[i][0]);
          let polygon = createGeometry(vtriangles[i]);
          let newDevelopmentGraphic = new Graphic({
            geometry: polygon,
            symbol: validSymbol,
            attributes: {
              newDevelopment: "new store",
              cellindex:(i+1).toString(),
              polygonindex:i.toString()
            }
          });
          text_symbol.text="S"+(i+1).toString();
          let t_point=new Graphic ({
            geometry:newDevelopmentGraphic.geometry.centroid,
            symbol:text_symbol
          });
          allpolygons.push(newDevelopmentGraphic);
          allpolygons_text.push(t_point);
        }
        updated_polygonring=vtriangles;

        graphicsLayer.addMany(allpolygons);
        graphicsLayer.addMany(allpolygons_text);

      }
      function DrawCell2D(graphic_in){
        graphicLayer_hit_2D.removeAll();
        const fillSymbol = {
          type: "simple-fill", // autocasts as new SimpleFillSymbol()
          color: [0, 96, 255, 0.9],
          outline: {
            color: [255, 255, 255],
            width: 1
          }
        };
        const polygon = createGeometry(graphic_in.geometry.rings);
        let newDevelopmentGraphic = new Graphic({
          geometry: polygon,
          symbol: fillSymbol
        });
        graphicLayer_hit_2D.add(newDevelopmentGraphic);
      }

      function addGraphics3D(vtriangles) {
        //validSymbol = createSymbol([0, 170, 255, 0.4], "solid", 2, [255,255, 255]);
        let polygon3D=[];
        for (let i=0;i<vtriangles.length;i++){
          vtriangles[i].push(vtriangles[i][0]);
          let polygon = createGeometry(vtriangles[i]);
          let newDevelopmentGraphic = new Graphic({
            geometry: polygon,
            symbol: validSymbol,
            attributes: {
              newDevelopment: "3D",
              cellindex:(i+1).toString(),
              polygonindex:i.toString()
            }
          });
          polygon3D.push(newDevelopmentGraphic);
        }
        //console.log(polygon3D);
        gridsLayer3D.addMany(polygon3D);
      }

      function DrawCell3D(graphic_in){
        graphicLayer_hit_3D.removeAll();
        const fillSymbol = {
          type: "simple-fill", // autocasts as new SimpleFillSymbol()
          color: [204, 232, 205, 0.4],
          outline: {
            color: [153, 209, 255],
            width: 3
          }
        };
        const polygon = createGeometry(graphic_in.geometry.rings);
        let newDevelopmentGraphic = new Graphic({
          geometry: polygon,
          symbol: fillSymbol
        });
        graphicLayer_hit_3D.add(newDevelopmentGraphic);
        //console.log(graphicLayer_hit_3D);
      }


      function createGeometry(vertices) {
        return new Polygon({
          rings: vertices,
          //spatialReference: {wkid: 102100 }
          spatialReference: view.spatialReference
        });
      }

      function createSymbol(color, style, width, outlineColor) {
        return {
          type: "simple-fill",
          style: style,
          color: color,
          outline: {
            color: outlineColor,
            width: width
          }
        }
      }
      // Create new view, map and layers... set up the view
      function setupView3D(){
        const map3D = new Map({
          basemap: "arcgis-imagery",//"topo-vector","arcgis-topographic",
          ground: "world-elevation"
        });
        view3D = new SceneView({
          container: "viewDiv3D",
          map: map3D,
          camera: {
            position: {
              x: m_exp_location.center[0]+m_camera_x_offset,//m_expsetupobj.location_3D[m_exp_loc_index].camera_x,
              y: m_exp_location.center[1]+m_camera_y_offset,//-0.0089372,//m_expsetupobj.location_3D[m_exp_loc_index].camera_y,//
              z: 2665 // meters, 1250
            },
            tilt: 53,//74.3,
            heading: 78,//322,
            fov:55
          },
        });

        map3D.add(graphicLayer_contour_3D);
        map3D.add(graphicsLayer3D);
        map3D.add(gridsLayer3D);
        map3D.add(graphicsLayer3D_point);
        map3D.add(graphicLayer_hit_3D);
        map3D.add(graphicLayer_clue_3D);
        map3D.add(graphicLayer_heightline_3D);
        map3D.add(graphicsLayer3D_UAVPath);

        const editArea = document.getElementById("editArea");
        const editExpand = new Expand({
            expandIconClass: "esri-icon-edit",
            expandTooltip: "Expand Edit",
            expanded: true,
            view: view3D,
            content: editArea,
            autoCollapse:true
        });
        view3D.ui.add(editExpand, "top-right");

        let ccWidget = new CoordinateConversion({
          view: view3D
        });
        view3D.ui.add(ccWidget, "bottom-right");

        view3D.ui.add("showtarget", "top-left");

        view3D.ui.add("map2Dvs3D", "top-left");
      }
      function setUpView() {
        coordinateLayer=new FeatureLayer({
          //wkid:4326
          //spatialReference: { wkid: 4326  }
          spatialReference: { wkid: 102100  }
        });
        let transportationLayer = new TileLayer({
          url: "https://server.arcgisonline.com/arcgis/rest/services/Reference/World_Transportation/MapServer",
          // This property can be used to uniquely identify the layer
          id: "something",
          visible: true
        });
        //map.add(transportationLayer);
        let riverLayer = new FeatureLayer({
          url:
          "https://services8.arcgis.com/ZXMBUOxDBbivoAgJ/arcgis/rest/services/RiverMiles/FeatureServer"
          // This property can be used to uniquely identify the layer
        });
        //map.add(riverLayer);
        //console.log(riverLayer.gdbVersion);
        view = new MapView({
          container: "viewDiv2D",
          map: map,
          zoom: scale,
          center: m_exp_location.center//m_scenarios[m_scenario_index].center//[gcx,gcy],//,35.4
        });
        m_experimentres["scenario"]=m_scenarios[m_scenario_index];
        m_experimentres["lostpersontype"]=m_lostpersontype[m_lostpersontype_index];

        let toggle = new BasemapToggle({
          // 2 - Set properties
          view: view, // view that provides access to the map's 'topo' basemap
          nextBasemap: "topo-vector" // allows for toggling to the 'hybrid' basemap
        });
        // Add widget to the top right corner of the view
        view.ui.add(toggle, "bottom-left");
        //add track widget
        let trackWidget = new Track({
          view: view
        });
        view.ui.add(trackWidget, "top-left");
        // Adds the search widget below other elements in
        // the top left corner of the view
        let searchWidget = new Search({
          view: view
        });
        view.ui.add(searchWidget, {
          position: "bottom-right",
          index: 5
        });
        draw = new Draw({
          view: view
        });
        //validSymbol = createSymbol([0, 170, 255, 0.4], "solid", 2, [255,255, 255]);//task generation
        validSymbol = createSymbol([212,221,222, 0.2], "solid", 2, [255,255, 255]);//task generation
        m_colorgroup = ColorGroupInitialize();
        document.getElementById("btic").value=m_exp_location.name;
      }



      document.getElementById("btneditcells").onclick=function() {

        if(m_editing){
          document.getElementById("btneditcells").value="Edit cells (Stop)";
          m_experimentres["actions"].push({"id":"btneditcells","timestamp": Date.now(), "description":"Edit cells stops"});
          m_editing=false;
        }
        else{
          document.getElementById("btneditcells").value="Edit cells (Editing)";
          m_editing=true;
          m_experimentres["actions"].push({"id":"btneditcells","timestamp": Date.now(), "description":"Edit cells start"});
        }


      }
        //generate voronoi
      document.getElementById("btngeneratearea").onclick=function() {
        m_experimentres["actions"].push({"id":"btngeneratearea","timestamp": Date.now(), "description":"generate task"});
        graphicsLayer.removeAll();
        view.graphics.removeAll();
        pathplanninggraphicsLayer.removeAll();

        epsg4326_voronoiarr=[];
        //wholetask=activeWidget.viewModel.measurement;
        allpolygons=[];
        allpolygons_text=[];
        glverticeslist=[];
        if(voronoistyle=="random"){
          addVoronoi();
          //view.complete();
        }
        else if(voronoistyle=="triangle"){
          //addTriangle();
          //view.complete();
        }
        else if(voronoistyle=="clear"){
          addFreedraw();
        }

        DisplayLostPersonInfo();

        //m_experimentres["allpolygons"]=allpolygons;
        m_experimentres["polygonnumbers"]=allpolygons.length;
        //load target and calculate their regions.
        //m_targetpolygon=allpolygons[getRandomInt(allpolygons.length)];
        SetTargetpolygon();
        if(m_targetpolygon){
          m_experimentres["targetcellindex"]=m_targetpolygon.attributes.cellindex;
        }

        m_experimentres["scenario"]=m_scenarios[m_scenario_index];
        m_experimentres["lostpersontype"]=m_lostpersontype[m_lostpersontype_index];

      };
      function TaskGenerateArea_2D_3D(){
        m_experimentres["actions"].push({"id":"btngeneratearea","timestamp": Date.now(), "description":"generate task"});
        graphicsLayer.removeAll();
        view.graphics.removeAll();

        pathplanninggraphicsLayer.removeAll();

        epsg4326_voronoiarr=[];
        allpolygons=[];
        allpolygons_text=[];
        addVoronoi();

        SetTargetpolygon();
      };

      // target data is in the m_targetandclues object
      // function updated after the clue updates v2.1
      function SetTargetpolygon(){
        //console.log(m_targetandclues);
        let t_pt=new Point({
          latitude: m_targetandclues.target[1],
          longitude: m_targetandclues.target[0],
          spatialReference: view.spatialReference
        });
        //console.log(t_pt);
        //console.log(allpolygons);
        //console.log(t_pt);
        //console.log(allpolygons);
        for(let i=0;i<allpolygons.length;i++){
          if(geometryEngine.contains(allpolygons[i].geometry,t_pt)){
            m_targetpolygon=allpolygons[i];
            break;
          }
        }
      }

      // this function is called from the polygon draw action events
      // to provide a visual feedback to users as they are drawing a polygon
      function drawPolygon(event) {
        if(voronoistyle!="clear") return;
        let glvertices = event.vertices;
        //remove existing graphic
        view.graphics.removeAll();
        if(glverticeslist.length>0) addGraphics(glverticeslist);
        // create a new polygon
        let polygon = new Polygon({
          rings: glvertices,
          spatialReference: view.spatialReference
        });
        // create a new graphic representing the polygon, add it to the view
        //taskgeneration
        let graphic = new Graphic({
          geometry: polygon,
          symbol: {
            type: "simple-fill", // autocasts as SimpleFillSymbol
            color: [178, 102, 234, 0.8],//[178, 102, 234, 0.1],
            style: "solid",
            outline: { // autocasts as SimpleLineSymbol
              color: [255, 255, 255],
              width: 2
            }
          }
        });
        view.graphics.add(graphic);
        // calculate the area of the polygon
        let area = geometryEngine.geodesicArea(polygon, "acres");
        if (area < 0) {
          // simplify the polygon if needed and calculate the area again
          let simplifiedPolygon = geometryEngine.simplify(polygon);
          if (simplifiedPolygon) {
            area = geometryEngine.geodesicArea(simplifiedPolygon, "acres");
          }
        }
        // start displaying the area of the polygon
        labelAreas(polygon, area);
        if(event.type=="draw-complete"){
          addGraphics(glvertices);
          if( voronoistyle=="clear"){
            glverticeslist.push(glvertices);
            //addFreedraw();
          }
        }
      }

      //Label polyon with its area
      function labelAreas(geom, area) {
        let graphic = new Graphic({
          geometry: geom.centroid,
          symbol: {
            type: "text",
            color: "white",
            haloColor: "black",
            haloSize: "1px",
            text: area.toFixed(2) + " acres",
            xoffset: 3,
            yoffset: 3,
            font: { // autocast as Font
              size: 14,
              family: "Josefin Slab"
            }
          }
        });
        view.graphics.add(graphic);
      }


      //view.ui.add(ccWidget,document.getElementById("coordinatesdiv"));
//-----------------adding new functions here---------------------

      function onGraphicUpdate(event){
        let mover,temppolyset,t_pointIndex,orignalmover;//for reshape
        let t_pt_array;//for move

        //if(event.toolEventInfo != null){
        //console.log(event.toolEventInfo.mover.geometry.x +","+ event.toolEventInfo.mover.geometry.y+":"+ event.toolEventInfo.type );
        //}
        //if is the first active or not
        if (event.state=="active"){
          let graphic = event.graphics[0];
          //console.log(event);
          let t_status=0;//1: "reshape", 2: "move";
          mover=event.toolEventInfo.mover.geometry;
          //console.log(event.toolEventInfo.mover);


          if(event.toolEventInfo.type=="reshape-start"){
            t_status=1;
            t_pointIndex=event.toolEventInfo.mover.attributes.pointIndex;
            orignalmover=graphic.geometry.rings[0][t_pointIndex];

            temppolyset=[];
            activepolygonpoints=[];
            //selected=event.toolEventInfo.selected[0].geometry;
            for(let i=0;i<allpolygons.length;i++){
              if(geometryEngine.equals(allpolygons[i].geometry,graphic.geometry)){
                temppolyset.push(allpolygons[i]);
                continue;
              }
              if(geometryEngine.touches(mover,allpolygons[i].geometry)){
                //array, start end with the two nearby points
                //let array_points=GetPolygonPoints(mover.x,mover.y,allpolygons[i].geometry.rings[0]);
                let array_points=GetPolygonPoints(orignalmover[0],orignalmover[1],allpolygons[i].geometry.rings[0]);

                activepolygonpoints.push(array_points);
                //console.log("mover"+mover.x+","+mover.y);
                //console.log("original"+orignalmover[0]+","+orignalmover[1]);
                //console.log(activepolygonset);
                activepolygonset.push(allpolygons[i]);
              }
              else{
                temppolyset.push(allpolygons[i]);
              }
            }
            allpolygons=temppolyset;
          }
          else if(event.toolEventInfo.type=="reshape"){
            t_status=1;
          }
          else if(event.toolEventInfo.type=="reshape-stop"){

            allpolygons=allpolygons.concat(activepolygonset);
            activepolygonset=[];
            t_status=1;
          }
          else if(event.toolEventInfo.type=="move-start"){
            temppolyset=[];
            activepolygonpoints=[];
            //validSymbol = createSymbol([0, 170, 255, 0.4], "solid", 2, [255,255, 255]);
            t_status=2;
            for(let i=0;i<allpolygons.length;i++){
              if(geometryEngine.equals(allpolygons[i].geometry,graphic.geometry)){
                move_polygon = new Graphic({
                  geometry: allpolygons[i].geometry,
                  symbol: validSymbol,
                  attributes: {
                    newDevelopment: "new store",
                    cellindex: allpolygons[i].attributes.cellindex,
                    polygonindex: allpolygons.length
                  }
                });
                activepolygonset.push(allpolygons[i]);
                continue;
              }
              temppolyset.push(allpolygons[i]);
            }
            allpolygons=temppolyset;
          }
          else if(event.toolEventInfo.type=="move"){
            t_status=2;
          }
          else if(event.toolEventInfo.type=="move-stop"){
            t_status=2;
            allpolygons.push(move_polygon);
            //console.log(allpolygons);
            graphicsLayer.removeMany(activepolygonset);
            graphicsLayer.addMany([move_polygon]);

            activepolygonset=[];
          }
          //renew the polygons
          if(activepolygonset.length>0 && t_status==1){

            graphicsLayer.removeMany(activepolygonset);
            activepolygonset=GeneratePolygonBasedonPoints(mover.x,mover.y,activepolygonpoints);
            graphicsLayer.addMany(activepolygonset);

          }

        }
      }


      //tpoly is an array[[,],[,]]
      function GetPolygonPoints(x,y,tpoly){
        //break the ring

        let t_array=[];
        let i=0;
        let pointofline=0;//0: not on line, 1: vertices, 2: center, 3: on the line
        for(i=0;i<tpoly.length-1;i++){
          if((Math.abs(tpoly[i][0]-x)< maxdistanceerror) && (Math.abs(tpoly[i][1]-y)< maxdistanceerror )){
            pointofline=1;
            break;
          }
        }
        if( pointofline===1 ){
          //console.log("points as vertices");
          //poins as vertices of the line
          t_array=t_array.concat(tpoly.slice(i+1,tpoly.length-1),tpoly.slice(0,i));
          //console.log(t_array);
          return t_array;
        }

        for(i=0;i<tpoly.length-1;i++){
          if( ( Math.abs(0.5*( tpoly[i][0]+tpoly[i+1][0] )-x )< maxdistanceerror)
                && ( Math.abs(0.5*( tpoly[i][1]+tpoly[i+1][1] )-y) < maxdistanceerror) ){
                    pointofline=2;
                    break;
          }
        }
        if (pointofline===2){

          //have problem need debug
          t_array=t_array.concat(tpoly.slice(i+1,tpoly.length-1),tpoly.slice(0,i+1));
        }
        else{
          //poins on the line
          //add more pass

          t_array=null;
        }
        return t_array;
      }

      //update new polygon
      function GeneratePolygonBasedonPoints(x,y,array_points){
        let tmppolysets=[];

        //validSymbol = createSymbol([0, 170, 255, 0.4], "solid", 2, [255,255, 255]);

        if(array_points.length==0){
          return tmppolysets;
        }
        for(let i=0;i<array_points.length;i++){
          entry=array_points[i];

          let vertices=[];
          vertices=vertices.concat([[x,y]],entry,[[x,y]]);
          //console.log(vertices);
          //console.log("-------------");
          let polygon = createGeometry(vertices);
          newDevelopmentGraphic = new Graphic({
            geometry: polygon,
            symbol: validSymbol,
            attributes: {
              newDevelopment: "new store"
            }
          });
          tmppolysets.push(newDevelopmentGraphic);
        }

        return tmppolysets;
      }

      function PointsMerge(points_array,maxd){
        //ring with no points repeated

        resarray=[];
        while(points_array.length>0){
          entry=points_array.pop();
          //console.log(entry);
          //console.log("point merge");
          let i=0;
          for(i = 0;i<points_array.length;i++){
            if(Math.abs(points_array[i][0]-entry[0]< maxd) && Math.abs(points_array[i][1]-entry[1])< maxd ){
              break;
            }
          }
          if(i<points_array.length){
            continue;
          }
          else{
            resarray.push(entry);
          }
        }
        return resarray;
      }
//-----------------------------------------------------
      document.getElementById("distanceButton").addEventListener("click",
             function () {
               setActiveWidget(null);
               if (!this.classList.contains('active')) {
                 setActiveWidget('distance');
               } else {
                 setActiveButton(null);
               }
               m_experimentres["actions"].push({"id":"distanceButton","timestamp": Date.now(), "description":"generate task"});
             });

      document.getElementById("areaButton").addEventListener("click",
       function () {
         setActiveWidget(null);
         if (!this.classList.contains('active')) {
           setActiveWidget('area');
         } else {
           setActiveButton(null);
         }
       });

      function setActiveWidget(type) {
       switch (type) {
         case "distance":
           activeWidget = new DistanceMeasurement2D({
             view: view
           });

           // skip the initial 'new measurement' button
           activeWidget.viewModel.newMeasurement();
           activeWidget.

           view.ui.add(activeWidget, "bottom-right");
           setActiveButton(document.getElementById('distanceButton'));
           break;
         case "area":
           activeWidget = new AreaMeasurement2D({
             view: view
           });

           // skip the initial 'new measurement' button
           activeWidget.viewModel.newMeasurement();

           view.ui.add(activeWidget, "bottom-right");
           //console.log(activeWidget);
           setActiveButton(document.getElementById('areaButton'));
           break;
         case null:
           if (activeWidget) {
             view.ui.remove(activeWidget);
             activeWidget.destroy();
             activeWidget = null;
           }
           break;
       }
      }

      function setActiveButton(selectedButton) {
         // focus the view to activate keyboard shortcuts for sketching
         view.focus();
         let elements = document.getElementsByClassName("active");
         for (let i = 0; i < elements.length; i++) {
           elements[i].classList.remove("active");
         }
         if (selectedButton) {
           selectedButton.classList.add("active");
         }
       }

      document.getElementById("clearall").addEventListener("click",
      function () {
       m_experimentres["actions"].push({"id":"clearall","timestamp": Date.now(), "description":"clearall"});
       m_lpdata_con=[];
       m_lpdata_trial=[];
       m_lpdata_trajectory=[];
       m_lpdata_tra_colormap=[];

       ClearAll();
       area_extent=view.extent;
      });

       function ClearAll(){
         allpolygons=[];
         allpolygons_text=[];
         activepolygonset=[];
         activepolygonpoints=[];
         glverticeslist=[];
         updated_polygonring=[];
         m_visualizationtype='byhour';

         // change clue status from 'show' to 'unfound'
         for (let j=0;j<m_targetandclues.clue.length;j++){
           m_targetandclues.clue[j].status='unfound';
         }
         //area_extent=view.extent;
         graphicsLayer.removeAll();
         view.graphics.removeAll();
         pathplanninggraphicsLayer.removeAll();
         graphicInitLayer.removeAll();
         visualization_Contourmap_Layer.removeAll();
         visualization_Trajectories_Layer.removeAll();
         visualization_Cone_Layer.removeAll();
         temperalgraphicLayer.removeAll();
         visualization_Segmentheat_Layer.removeAll();
         graphicLayer_hit_2D.removeAll();

         gridsLayer3D.removeAll();
         graphicsLayer3D.removeAll();
         graphicLayer_contour_3D.removeAll();
         graphicsLayer3D_point.removeAll();
         graphicLayer_hit_3D.removeAll();
         graphicLayer_clue_3D.removeAll();
         graphicLayer_heightline_3D.removeAll();
         graphicsLayer3D_UAVPath.removeAll();

         setActiveWidget(null);
         sketchViewModel.complete();
         view.ui.remove(activeWidget);
         //activeWidget.destroy();
         activeWidget = null;

         document.getElementById("infocontent").value = "LPM Data";
         document.getElementById("searchResults").innerHTML="Search results: NA";
         document.getElementById("detectedClueRes").innerHTML="You selected: NA";
         document.getElementById("myRangeTrust").value=50;
         document.getElementById("myRangeTrustAmount").innerHTML=50;
         m_trialindex=0;
       }

       function PolyArrayToJson(polyarray)
       {
         if(polyarray.length<1){
           return "";
         }
         res_json={};
         for (let i=0;i<polyarray.length;i++){
           res_json[i]=polyarray[i];
         }
         return JSON.stringify(res_json);
       }

       document.getElementById("savetasks").addEventListener("click",
         function () {
           m_experimentres["actions"].push({"id":"savetasks","timestamp": Date.now(), "description":"savetasks"});
           let py_task_all_array={{ task_all |safe }}
           let t_tasknotes=document.getElementById("tasknotes").value;
           t_tasknotes=t_tasknotes.split(' ').join('_');
           //console.log(py_task_all_array);
           if(py_task_all_array.includes(t_tasknotes)){
             //task_all
             alert("Please try another task name.");
             //console.log(document.getElementById("tasknotes").value+" is already exist, please enter another one!");
           }
           else {
             let URL = "{% url 'tasksave' %}";
             let dbpolystr=PolyArrayToJson(updated_polygonring);
             let data = {
                     csrfmiddlewaretoken: '{{ csrf_token }}',
                     'task_notes': t_tasknotes,
                     'task_id': t_tasknotes,
                     'Taskarea': updated_polygonring.length.toString(),
                     'task_polygon': dbpolystr
                    };
             $.post(URL, data, function(response){
               let res=JSON.parse(response);

                 if(res.flag == 'success'){
                   //console.log(res.Taskarea);
                   //add date and task number and a random number
                   //task name:
                   let task_url="{% url 'taskgenerationform' %}"+"/"+t_tasknotes+'_'+'0/';
                   //console.log(task_url);
                   //let win = window.open("{% url 'taskgenerationform' %}", '_blank');
                   let win = window.open(task_url, '_blank');
                   win.focus();
                   //open a new tab for task TaskGeneration

                  }
                 else{ alert(response); }
             });
           }
         });
         function LoadLPFromCSV_Tra_Item(t_url,t_rank=0,t_index=0){
           let t_data;
            $.ajax({
              type: "GET",
              url:t_url,
              dataType: "text",
              success: function(response)
              {
                 t_data = $.csv.toArrays(response).map(function(item){
                   return item.map(Number);
                 });
                 m_lpdata_trajectory.push({'index':t_index,'notes':'clue','clue':t_index,'data':t_data});

              }
            });
            return true;
         }
         function LoadLPFromCSV_Tra_All(t_url,t_rank=0,t_index=0){

           let t_data;
            $.ajax({
              type: "GET",
              url:t_url,
              dataType: "text",
              success: function(response)
              {
                 t_data = $.csv.toArrays(response).map(function(item){
                   return item.map(Number);
                 });
                 // column: time by hour, lon,lat,index of trajectory
                 // cut t_data into 2 dimentional array every 13 items [ [t_data[1],t_data[2]],[],..,[] ]

                 let all_obj={};
                 let sizeoftrajectory=100;
                 let startpoint=1;
                 //initialize all_obj
                 for (let i=startpoint;i<sizeoftrajectory+1;i++){
                   let t_obj={};
                   all_obj[i]=t_obj;
                 }
                 // clean the data
                for(let i=0;i<t_data.length;i++){
                  all_obj[t_data[i][3]][t_data[i][0]]=[t_data[i][1],t_data[i][2]];
                }

                // trans obj to arr
                let res_arr=[];
                for(let i=0;i<=GetObjectLength(all_obj);i++){
                  if (i in all_obj){
                    res_arr.push(Object.values(all_obj[i]));
                  }

                }
                //console.log(res_arr);

                 m_lpdata_trajectory.push({'index':-1,'notes':'all','data':res_arr});

                 m_colormap=document.getElementById("sel_colormap").selectedIndex;
                 let t_color_arr=[];
                 let t_ratio=1.0/sizeoftrajectory;

                 for (let j=0;j<sizeoftrajectory;j++){
                   t_rgb=hslToRgb(1-t_ratio*j, 1, 1-0.6*t_ratio*j);//rainbow
                   t_color_arr.push(t_rgb);
                   //t_color_arr.push([getRandomInt(255), getRandomInt(255), getRandomInt(255)]);
                 }
                 m_lpdata_tra_colormap.push(t_color_arr);

                 t_color_arr=[];
                 for (let j=0;j<sizeoftrajectory;j++){
                   let t_rgb=hslToRgb(0.2*(1-t_ratio*j), 1, 1-t_ratio*j);
                   t_color_arr.push(t_rgb);
                   //t_color_arr.push([255-255*t_ratio*j,0,0]);
                 }
                 m_lpdata_tra_colormap.push(t_color_arr);
                 t_color_arr=[];
                 for (let j=0;j<sizeoftrajectory;j++){
                  let t_rgb=hslToRgb(0.6, 1, 1-0.5*t_ratio*j);
                  t_color_arr.push(t_rgb);
                }
                m_lpdata_tra_colormap.push(t_color_arr);
              }
            });
            return true;
         }

         function LoadLPFromCSV_trial(t_url,t_rank=0,t_index=0){
           let t_data;
            $.ajax({
              type: "GET",
              url:t_url,
              dataType: "text",
              success: function(response)
              {
                 t_data = $.csv.toArrays(response).map(function(item){
                   return item.map(Number);
                 });
                 m_lpdata_trial.push({'index':t_index,'rank':t_rank,'data':t_data});
                 //console.log(m_lpdata_trial);
              }
            });
            return true;
         }

         // Loading contour map
         function LoadLPFromCSV_con(t_url,t_arr_count,t_hour=0,t_rank=0,t_type='byhour'){
           let t_data;
            $.ajax({
              type: "GET",
              url:t_url,
              dataType: "text",
              success: function(response)
              {
                 t_data = $.csv.toArrays(response).map(function(item){
                   return item.map(Number);
                 });
                 m_lpdata_con.push({'type':t_type,'hour':t_hour,'rank':t_rank,'data':t_data});
                 //console.log(m_lpdata_con.length, t_arr_count);
                 if (m_lpdata_con.length >= t_arr_count){

                   document.getElementById("loadlpmcsv").value="Load LPM Data (Loaded)";
                   m_experimentres["actions"].push({"id":"loadlpmcsv","timestamp": Date.now(), "description":"loaded"});

                   document.getElementById("infocontent").innerHTML="LPM Data (Loaded)";
                   SetTargetClues();
                 }
              }
            });
            return true;
         }

         function AddCluetoInteractionImagelayer(){
           graphicInteractionLayer.removeAll();
           //display all clue points
           arr_featureset=[];
           for (let i=0;i<m_targetandclues.clue.length;i++){
             if(m_targetandclues.clue[i].status=="show"){
               let in_point=new Point({
                 longitude:m_targetandclues.clue[i].data[0],
                 latitude:m_targetandclues.clue[i].data[1],
                 spatialReference:view.spatialReference
               });
               let t_graphic =  new Graphic({
                 geometry: in_point,
                 symbol:  {
                      type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                      style:"circle",
                      color: [255,0,0],
                      size: 40
                    },
                  attributes:{
                    Name:"Clue",
                    Rank:1
                  }
               });
               arr_featureset.push(t_graphic);
             }
           }
           graphicInteractionLayer.addMany(arr_featureset);
           graphicInteractionLayer.visible=true;
         }

         // this function has delay
         function getClueImageByPhotoid(photoid){
           let URL = "{% url 'getcluemedia' %}";
           let data = {
                   csrfmiddlewaretoken: '{{ csrf_token }}',
                   'photoid': photoid.toString()
                  };
           $.post(URL, data, function(response){
             let res=JSON.parse(response);
               if(res.flag == 'success'){
                 //console.log(res);
                }
               else{ alert(response); }
           });
         }
         function DrawToTemperalGraphicLayer(obj,type){
           temperalgraphicLayer.removeAll();
           // ajax load image from database aka ClueMedia

           // lost person target position
           if(type==="point"){
             // draw obj to temperalgraphicLayer
             let in_point=new Point({
                     latitude:obj[1],//lat,
                     longitude:obj[0],//long,
                     spatialReference:view.spatialReference
                   });
             let t_graphic1=  new Graphic({
               geometry: in_point,
               symbol:  {
                    type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                    style:"circle",
                    color: [getRandomInt(255), getRandomInt(255), getRandomInt(255)],//[t_mag, 0,0],
                    size:20
                  },
                attributes:{
                  Name:"Target",
                  Hour:0,
                  Rank:1
                }
             });
             temperalgraphicLayer.add(t_graphic1);

             let t_clue=m_targetandclues;


             for (let i=0;i<m_exp_location.clue.length;i++){
               let in_point=new Point({
                 longitude:m_exp_location.clue[i].location[0],
                 latitude:m_exp_location.clue[i].location[1],
                 spatialReference:view.spatialReference
               });

               let t_clueobj;

               let URL = "{% url 'getcluemedia' %}";
               let data = {
                 csrfmiddlewaretoken: '{{ csrf_token }}',
                 'photoid': m_exp_location.clue[i].photoid.toString()
               };
               $.post(URL, data, function(response){
                 t_clueobj=JSON.parse(response);
                 //console.log(t_clueobj);
                 if(t_clueobj.flag == 'success'){

                   let t_graphic =  new Graphic({
                     geometry: in_point,
                     symbol:  {
                       type: "picture-marker",  // autocasts as new PictureMarkerSymbol()
                       url: "{% static 'img/clue2.png' %}",//user.png
                       width: "32px",
                       height: "32px"
                       /*
                          type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                          style:"square",
                          color: [255,0,0],
                          size: 40
                          */
                        },
                      attributes:{
                        Name:"Clue",
                        Hour:0,
                        Rank:1
                      },
                      popupTemplate:{
                          title: "Clue_"+t_clueobj.cluephotoid+", ("+ t_clueobj.lon +","+t_clueobj.lat+")",
                          content:[{
                            type: "media",
                            mediaInfos: [{
                              title: t_clueobj.name,
                              type: "image",
                              caption: t_clueobj.detail,
                              value: {
                                sourceURL: t_clueobj.url
                              }
                            }]
                          }
                        ]
                      }
                   });
                   temperalgraphicLayer.add(t_graphic);
                  }
                 else{ alert(response); }
               });


             }
           }

           temperalgraphicLayer.visible=true;
         }
         function GetConePoints(center,clue,diameter,angle=0.1) {
           let y=clue[1]-center[1];
           let x=clue[0]-center[0];
           //console.log(Math.sqrt(x*x+y*y));
           let i_angle=angle*Math.PI;
           let t_angle=0;
           if(x==0){
             if(y>0){
                t_angle=0.5*Math.PI;
             }
             else{
               t_angle=-0.5*Math.PI;
             }
           }
           else{
             t_angle=Math.atan(y/x);
           }

           let left=t_angle+i_angle;
           let right=t_angle-i_angle;
           let lpt,rpt;
           if (x>0){
             lpt=[diameter*Math.cos(left)+center[0] , diameter*Math.sin(left)+center[1]];
             rpt=[diameter*Math.cos(right)+center[0] , diameter*Math.sin(right)+center[1]];
           }
           else{
             //console.log([x,Math.PI,t_angle,i_angle]);

             left=-t_angle+i_angle;
             right=-t_angle-i_angle;

             lpt=[center[0]-diameter*Math.cos(left), diameter*Math.sin(left)+center[1]];
             rpt=[center[0]-diameter*Math.cos(right) , diameter*Math.sin(right)+center[1]];
           }
           return [lpt,center,rpt];
         }

         function AddLPDataToTrajectorylayer(t_type = "byhour"){
           let i_hr=parseInt(document.getElementById("myRange").value);
           m_colormap=document.getElementById("sel_colormap").selectedIndex;
           let clueindex=0;
           let t_arr=m_lpdata_trajectory.filter(obj=>{ return obj.index === -1;});
           let t_data=t_arr[0].data;

           if (t_type == "byclue"){
             clueindex=parseInt(document.getElementById("myClues").value);
             //console.log(clueindex);
             if(clueindex<4){
               let t_reduced_arr=[];
               // trajectory: 0: all, 1: clue 1, 2:clue2,3:clue1,2
               // contourmap: 0: clue1, 1: clue2, 2: clue1,2, 3: all
               let t_reduced_index_arr=m_lpdata_trajectory.filter(obj=>{ return obj.index === clueindex;});

               for(let i=0;i<t_reduced_index_arr[0].data.length;i++){
                 //console.log(t_data[t_reduced_index_arr[0].data[i]-1]);
                 t_reduced_arr.push(t_data[t_reduced_index_arr[0].data[i]-1]);
               }
               //console.log(t_reduced_arr);
               t_data=t_reduced_arr;
               //console.log(t_data);
             }
             else{
               clueindex=0;
             }
           }
           else if(t_type == "byhour"){
             clueindex=0;
           }
           visualization_Trajectories_Layer.removeAll();
           //console.log(t_data);

           // display all 100 trajectories
           // filter m_lpdata_trial
           let arr_visual=[];

           let t_case = document.getElementById("displaytype").checked;  // default unchecked: bypath, checked: byhour

           if(t_case){ //byhour
             let mid_data=[];//13 items

             for (let j=0;j<12;j++){
               mid_data.push([]);
             }
             for(let i=0;i<t_data.length;i++){
               for (let j=1;j< t_data[i].length;j++){
                 mid_data[j-1].push([ [t_data[i][j][0],t_data[i][j][1]],[t_data[i][j-1][0],t_data[i][j-1][1]] ]);
                 // color map

               }
             }
             //t_data=mid_data;
             //console.log(m_lpdata_tra_colormap);
             for(let i=0;i<mid_data.length;i++){
               let polyline = {
                   type:'polyline',
                  paths: mid_data[i],
                  spatialReference: { wkid: 4326 }
                };
                let polylineGraphic=new Graphic({
                  geometry: polyline,
                  symbol:{
                          type: "simple-line", // autocasts as new SimpleLineSymbol()
                          color: m_lpdata_tra_colormap[m_colormap][(11-i)*9], // RGB color values as an array
                          width: 1
                        }
                });
                                //console.log(polylineGraphic);
                arr_visual.push(polylineGraphic);
             }
             for(let i=0;i<mid_data[i_hr].length;i++){
               let t_color= m_lpdata_tra_colormap[m_colormap][(11-i_hr)*9];
               if (i_hr>=t_data.length){
                 i_hr=t_data.length-1;
                 t_color=[125,125,125,0.1];
               }
               else if( i_hr >0){
                 // compare
                 if(mid_data[i_hr][i][0][1]==mid_data[i_hr][i][1][1] && mid_data[i_hr][i][0][0]==mid_data[i_hr][i][1][0])
                 {
                   t_color=[125,125,125,0.1];
                 }

               }
               let t_pt={
                 type:'point',
                 latitude: mid_data[i_hr][i][0][1],
                 longitude: mid_data[i_hr][i][0][0]
               }
               let t_ptgraphic =  new Graphic({
                 geometry: t_pt,
                 symbol:  {
                      type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                      style:"circle",
                      color: t_color,// t_color,//[t_mag, 0,0],
                      size: 10
                    }
               });
               arr_visual.push(t_ptgraphic);
             }

           }
           else{
             //console.log(t_data);
             for(let i=0;i<t_data.length;i++){

               let polyline = {
                   type:'polyline',
                  paths: t_data[i],
                  spatialReference: { wkid: 4326 }
                };
                let polylineGraphic=new Graphic({
                  geometry: polyline,
                  symbol:{
                          type: "simple-line", // autocasts as new SimpleLineSymbol()
                          color: m_lpdata_tra_colormap[m_colormap][i], // RGB color values as an array
                          width: 1
                        }
                });
                //console.log(polylineGraphic);
                arr_visual.push(polylineGraphic);
             }
             for(let i=0;i<t_data.length;i++){
               let t_color=m_lpdata_tra_colormap[m_colormap][i];
               if (i_hr>=t_data.length){
                 i_hr=t_data.length-1;
                 t_color=[125,125,125,0.1];
               }
               else if( i_hr >0){

                 if(t_data[i][i_hr]!=null && t_data[i][i_hr-1]!=null){
                   if(t_data[i][i_hr][0]==t_data[i][i_hr-1][0] && t_data[i][i_hr][1]==t_data[i][i_hr-1][1]){
                     t_color=[125,125,125,0.1];
                   }
                 }
               }
               if(t_data[i][i_hr]!=null){
                 let t_pt={
                   type:'point',
                   latitude: t_data[i][i_hr][1],
                   longitude: t_data[i][i_hr][0]
                 }
                 let t_ptgraphic =  new Graphic({
                   geometry: t_pt,
                   symbol:  {
                        type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                        style:"circle",
                        color: t_color,//[t_mag, 0,0],
                        size: 10
                      }
                 });
                 arr_visual.push(t_ptgraphic);
               }

             }
           }

           visualization_Trajectories_Layer.addMany(arr_visual);
           visualization_Trajectories_Layer.visible=true;
         }

         function AddLPDataToConelayer(){

           visualization_Cone_Layer.removeAll();
           let angle=0.1; // 0~180, 0~1

           arr_featureset=[];
           //let t_clueindex=document.getElementById("myClues").value;

           for (let i=0;i<m_targetandclues.clue.length;i++){

             if(m_targetandclues.clue[i].status=="show"){

               let pt=m_targetandclues.clue[i].data;
               let initpt = m_scenarios[m_scenario_index].center;//[lat,log]

               // calculate a Cone
               // start -> ipp -> end
               let persontype=document.getElementById("sel_lpm").value;
               //1100  0.0083 : 100  0.000755
               let arr_start_init_end=GetConePoints(initpt,pt,0.0000076*m_scenarios_rings[persontype][1],angle);
               //console.log(arr_start_init_end);
               let paths=[];
               //paths.push(pt);
               //paths.push(initpt);
               paths.push(arr_start_init_end[0]);
               paths.push(arr_start_init_end[1]);
               paths.push(arr_start_init_end[2]);

               // draw the Cone

               let polyline = new Polyline({
                hasZ: false,
                hasM: true,
                paths: [paths],
                spatialReference: { wkid: 4326 }
              });
                let polylineGraphic=new Graphic({
                geometry: polyline,
                symbol:{
                        type: "simple-line", // autocasts as new SimpleLineSymbol()
                        color: [255,255,0], // RGB color values as an array
                        width: 1
                      }
              });
              //console.log(polylineGraphic);
              arr_featureset.push(polylineGraphic);
             }
           }
           visualization_Cone_Layer.addMany(arr_featureset);
           visualization_Cone_Layer.visible=true;
         }

         function AddLPDataToSegmentheatlayer(t_type = "byhour"){
           visualization_Segmentheat_Layer.removeAll();
           contourring_arr=[]
           arr_featureset=[];
           if(m_lpdata_con == null){
             return;
           }

           let t_data_con,t_hour;

           if (t_type == "byclue"){
             t_hour=document.getElementById("myClues").value;
           }
           else if(t_type == "byhour"){
             t_hour=document.getElementById("myRange").value;
           }

           let t_rank=parseInt(document.getElementById("sel_rank").value)-1;
           arr_heatpoints=[];

           let t_break=m_lpdata_con.length;
           let i=0;
           while(i<t_break){
             if(m_lpdata_con[i]['type']==t_type){
               if(m_lpdata_con[i]['hour']==t_hour && m_lpdata_con[i]['rank']==t_rank){
                 arr_heatpoints=m_lpdata_con[i]['data'];
                 break;
               }
             }
             i++;
           }

           m_colormap=document.getElementById("sel_colormap").selectedIndex;
           //loop to find rings
           let t_rings=[];//
           let all_paths=[];
           let t_startprobability=arr_heatpoints[0][0];

           let col3 = arr_heatpoints.map(function(value,index) { return value[0]; });
           let t_min = Math.min(...col3);
           let t_max=Math.max(...col3);
           let t_range=t_max-t_min;

           let t_mag=(t_startprobability-t_min)/t_range;

           let t_distance=0.0001;//define as a circle
           let t_len=0;
           m_colormap=document.getElementById("sel_colormap").selectedIndex;
           arr_heatpoints.map(function(item){
             t_len=t_rings.length-1;
             if(item[0]==t_startprobability){
               if(t_len>3){
                 if(t_distance<((item[1]-t_rings[t_len][0])*(item[1]-t_rings[t_len][0])+ (item[2]-t_rings[t_len][1])*(item[2]-t_rings[t_len][1]))){
                   t_rings.push(t_rings[0]);
                   contourring_arr.push(t_rings);
                   t_rings=[];
                 }
               }
             }
             else{
               t_rings.push(t_rings[0]);
               contourring_arr.push(t_rings);
               t_rings=[];
               t_startprobability=item[0];
               t_mag=(t_startprobability-t_min)/t_range;
             }
             t_rings.push(item.slice(1));
           });
           if(t_rings.length>0){
             t_rings.push(t_rings[0]);
             contourring_arr.push(t_rings);
             t_rings=[];
           }
           // send contourring_arr to back for process

           let voronoiarr=[];
           let markspatialreference="epsg3857";
           if(epsg4326_voronoiarr.length>1){
             markspatialreference="epsg4326";
             voronoiarr=epsg4326_voronoiarr;
           }
           else{
             markspatialreference="epsg3857";
             for(i=0;i<allpolygons.length;i++){
               voronoiarr.push(allpolygons[i].geometry.rings[0]);
             }
           }

           //console.log(voronoiarr);
           //console.log(contourring_arr);

           let URL = "{% url 'getsegmentVal' %}";
           let data = {
             csrfmiddlewaretoken: '{{ csrf_token }}',
             'contourarr': JSON.stringify(contourring_arr),
             'voronoiarr': JSON.stringify(voronoiarr),
             'spatialReference': markspatialreference
           };
           $.post(URL, data, function(response){
             t_obj=JSON.parse(response);
             if(t_obj.flag == 'success'){
               //console.log(t_obj);
               let colorarr=t_obj.segmentval;
               let updatevoronoiarr=t_obj.updatevoronoi;
               if (updatevoronoiarr.length>0){
                 epsg4326_voronoiarr=updatevoronoiarr;
               }

               for(let j=0;j<allpolygons.length;j++){
                 let polygonGraphic = new Graphic({
                   geometry: allpolygons[j].geometry,
                   symbol: {
                           type: "simple-fill",
                           color: [0, 0, 255,colorarr[j]/150],//[0, 0, colorarr[j]*0.5+125,colorarr[j]/255],
                           outline: {
                             style:"none"
                           }
                         }
                 });
                 //console.log(colorarr[j]);
                 arr_featureset.push(polygonGraphic);//t_graphic

               }
               //console.log(arr_featureset);
               visualization_Segmentheat_Layer.addMany(arr_featureset);
               visualization_Segmentheat_Layer.visible=true;
              }
             else{ alert(response); }
           });


         }

         function AddLPDataToContourlayer(t_type = "byhour"){
           visualization_Contourmap_Layer.removeAll();
           arr_featureset=[];
           if(m_lpdata_con == null){
             return;
           }
           //console.log(m_lpdata_con);

           let t_data_con,t_hour;

           if (t_type == "byclue"){
             t_hour=document.getElementById("myClues").value;
           }
           else if(t_type == "byhour"){
             t_hour=document.getElementById("myRange").value;
           }
           //console.log(m_lpdata_con);


           let t_rank=parseInt(document.getElementById("sel_rank").value)-1;
           arr_heatpoints=[];

           let t_break=m_lpdata_con.length;
           let i=0;
           while(i<t_break){
             if(m_lpdata_con[i]['type']==t_type){
               if(m_lpdata_con[i]['hour']==t_hour && m_lpdata_con[i]['rank']==t_rank){
                 arr_heatpoints=m_lpdata_con[i]['data'];
                 //console.log(m_lpdata_con[i]);
                 break;
               }
             }
             i++;
           }
           //console.log(arr_heatpoints);

           m_colormap=document.getElementById("sel_colormap").selectedIndex;
           //loop to find rings
           let t_rings=[];//
           let all_paths=[];
           let t_startprobability=arr_heatpoints[0][0];

           let col3 = arr_heatpoints.map(function(value,index) { return value[0]; });
           let t_min = Math.min(...col3);
           let t_max=Math.max(...col3);
           let t_range=t_max-t_min;

           let t_mag=(t_startprobability-t_min)/t_range;

           let markerSymbol = {
             type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
             color: [226, 119, 40],
             outline: {
               style:"none"
             }
           };
          let fillSymbol= {
            type: "simple-fill", // autocasts as SimpleFillSymbol
            color: [226, 119, 40],
            outline: { // autocasts as SimpleLineSymbol

              style:"none"
            }
          };
          let t_distance=0.0001;//define as a circle
          let t_len=0;
          let t_index=0;
          let t_oppacity=3;//0.8
          m_colormap=document.getElementById("sel_colormap").selectedIndex;
           arr_heatpoints.map(function(item){
             t_len=t_rings.length-1;
             if(item[0]==t_startprobability){
               if(t_len>3){
                 if(t_distance<((item[1]-t_rings[t_len][0])*(item[1]-t_rings[t_len][0])+ (item[2]-t_rings[t_len][1])*(item[2]-t_rings[t_len][1]))){
                   //console.log((item[1]-t_rings[0][0])*(item[1]-t_rings[0][0])+ (item[2]-t_rings[0][1])*(item[2]-t_rings[0][1]));
                   // if two points are two far away, define them as different circles
                   t_rings.push(t_rings[0]);
                   let tmulpt=new Polygon({
                      rings: t_rings.reverse(),//[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
                      spatialReference: { wkid: 4326 }
                    });
                    if (m_colormap==0){
                      t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
                    }
                    else if (m_colormap==1){
                      t_rgb=hslToRgb(0.2*(1-t_mag), 1, 1-0.5*t_mag);//red:0, yellow:0.2
                    }
                    else{
                      t_rgb=hslToRgb(0.6, 1, 1-0.5*t_mag);//blue:0.6
                    }
                    t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

                    fillSymbol.color=t_rgb;
                    let polylineGraphic = new Graphic({
                      geometry: tmulpt, // Add the geometry created in step 4
                      symbol: fillSymbol
                    });
                     arr_featureset.push(polylineGraphic);//t_graphic
                     t_index=t_index+1;

                   t_rings=[];
                 }
               }
             }
             else{
               //ori:t_rings.push(t_rings[t_rings.length-1]);
               t_rings.push(t_rings[0]);
               //console.log(t_rings);

               let tmulpt=new Polygon({
                  rings: t_rings.reverse(),//[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
                  spatialReference: { wkid: 4326 }
                });
                if (m_colormap==0){
                  t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
                }
                else if (m_colormap==1){
                  t_rgb=hslToRgb(0.2*(1-t_mag), 1, 1-0.5*t_mag);//red:0, yellow:0.2
                }
                else{
                  t_rgb=hslToRgb(0.6, 1, 1-0.5*t_mag);//blue:0.6
                }
                t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

                fillSymbol.color=t_rgb;
                let polylineGraphic = new Graphic({
                  geometry: tmulpt, // Add the geometry created in step 4
                  symbol: fillSymbol
                });
                 arr_featureset.push(polylineGraphic);//t_graphic
                 t_index=t_index+1;

                 t_rings=[];
                 t_startprobability=item[0];
                 t_mag=(t_startprobability-t_min)/t_range;
             }
             t_rings.push(item.slice(1));
           });
           if(t_rings.length>0){

             //ori:t_rings.push(t_rings[t_rings.length-1]);
             t_rings.push(t_rings[0]);
             //console.log(t_rings);

             let tmulpt=new Polygon({
                rings: t_rings.reverse(),//[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
                spatialReference: { wkid: 4326 }
              });
              if (m_colormap==0){
                t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
              }
              else if (m_colormap==1){
                t_rgb=hslToRgb(0.2*(1-t_mag), 1, 1-0.5*t_mag);//red:0, yellow:0.2
              }
              else{
                t_rgb=hslToRgb(0.6, 1, 1-0.5*t_mag);//blue:0.6
              }
              t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

              fillSymbol.color=t_rgb;
              let polylineGraphic = new Graphic({
                geometry: tmulpt, // Add the geometry created in step 4
                symbol: fillSymbol
              });
               arr_featureset.push(polylineGraphic);//t_graphic
               t_index=t_index+1;

               t_rings=[];
           }
           //console.log(arr_featureset);
           visualization_Contourmap_Layer.addMany(arr_featureset);
           visualization_Contourmap_Layer.visible=true;

         }


         function SetTargetClues(){
           if(m_lpdata_trajectory.length<=0){
             return;
           }
           // need m_lpdata_trajectory
           let t_plitphase=0.618;
           let t_targetarr=m_lpdata_trajectory.filter(obj=>{ return obj.index === -1;});

           // pick two point from t_targetarr
           let t_cluearr=m_lpdata_trajectory.filter(obj=>{ return obj.index === 3;});
           //console.log(m_lpdata_trajectory);

           let tlen_clue=t_cluearr[0].data.length-1;

           let index_tar=Math.floor(t_targetarr[0].data[0].length * t_plitphase);
           if(index_tar==0 || index_tar==4){
             index_tar==3;
           }
           let index_clue1=0;
           let index_clue2=4;

           m_targetandclues={
             "target":t_targetarr[0].data[0][index_tar],
             "clue":[{"clue_index":0,"status":"unfound","info":"cloth","data":t_targetarr[0].data[tlen_clue][index_clue1],'photoid':1},
                    {"clue_index":1,"status":"unfound","info":"drink","data":t_targetarr[0].data[tlen_clue][index_clue2],'photoid':2}]
            };

         }

         function DisplayLostPersonInfo(){
           graphicInitLayer.removeAll();
           let t_feature=[];

           let t_center=new Point({
             longitude:m_scenarios[m_scenario_index].center[0],
             latitude:m_scenarios[m_scenario_index].center[1],
             spatialReference:view.spatialReference
           });//m_scenarios[m_scenario_index].center;

           let t_graphic =  new Graphic({
             geometry: t_center,//area_extent.center,//view.extent.center,
             symbol:  {
                  type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                  style:"triangle",
                  color: [255,0,0],//[t_mag, 0,0],
                  size:10
                },
              attributes:{
                Name:"Last known position",
                LostHour:2,
                Type:"hiker"
              },
              popupTemplate:{
                  title: "{Name}",
                  content: [
                    {
                      type: "fields",
                      fieldInfos: [{fieldName: "Name"},{fieldName: "LostHour"},{fieldName: "Type"}]
                    }
                  ]
              }
           });
           t_feature.push(t_graphic);

            //draw 25%,50%,75% ring
           let rings_arr=[1100,3100,5800,18300];
           let persontype=document.getElementById("sel_lpm").value;//lpm_hiker
           rings_arr=m_scenarios_rings[persontype];
           let ringsname_arr=["25% ring","50% ring","75% ring","95% ring"];
           for(let i=0;i<4;i++){
             let t_circle=new Circle({
               center:t_center,//area_extent.center,
               radius:rings_arr[i]
             });
             t_graphic =  new Graphic({
               geometry: t_circle,//view.extent.center,
               symbol:  {
                    type: "simple-fill", // autocasts as new SimpleMarkerSymbol()
                    style:"none",
                    outline:{
                      color:[255,i*50,0,0.6-0.4*i/4],
                      width:2
                    }
                  },
                attributes:{
                  Name:ringsname_arr[i],
                  LostHour:2,
                  Type:"hiker"
                }
             });

             t_feature.push(t_graphic);
            }
            // draw team rectangle
            //from x: 0.05-0.6
            //from y: 0.1 - 0.3
            let t_rect=new Polygon({
              rings:[
                [0.85*view.extent.xmin+0.15*view.extent.xmax,0.02*view.extent.ymin+0.98*view.extent.ymax],
                [0.5*view.extent.xmin+0.5*view.extent.xmax,0.02*view.extent.ymin+0.98*view.extent.ymax],
                [0.5*view.extent.xmin+0.5*view.extent.xmax,0.08*view.extent.ymin+0.92*view.extent.ymax],
                [0.85*view.extent.xmin+0.15*view.extent.xmax,0.08*view.extent.ymin+0.92*view.extent.ymax],
                [0.85*view.extent.xmin+0.15*view.extent.xmax,0.02*view.extent.ymin+0.98*view.extent.ymax],
              ],
              spatialReference:view.spatialReference
            });

            t_graphic =  new Graphic({
              geometry: t_rect,//view.extent.center,
              symbol:  {
                   type: "simple-fill", // autocasts as new SimpleMarkerSymbol()
                   style:"none",
                   outline:{
                     color:[255,125,0,1],
                     width:2
                   }
                 },
               attributes:{
                 Name:"team group"
               }
            });
            //t_feature.push(t_graphic);

            let t_point=new Point({
              x:0.9*view.extent.xmin+0.1*view.extent.xmax,
              y:0.07*view.extent.ymin+0.93*view.extent.ymax,
              spatialReference:view.spatialReference
            });
            t_graphic=new Graphic ({
              geometry:t_point,
              symbol:{
                type: "text",  // autocasts as new TextSymbol()
                color: [255,125,0],//"white",
                haloColor: "black",
                haloSize: "1px",
                text: "Teams: ",
                xoffset: 3,
                yoffset: 3,
                font: {  // autocast as new Font()
                  size: 24,
                  family: "Josefin Slab",
                  weight: "bold"
                }
              }
            });
            //t_feature.push(t_graphic);
           graphicInitLayer.addMany(t_feature);
         }


         document.getElementById("loadlpmcsv").onclick=function() {
           if(document.getElementById("loadlpmcsv").value=="Load LPM Data (Loaded)"){
             //clear everything before loading anything

           }
           //draw initial condition centerpoints
           m_experimentres["actions"].push({"id":"loadlpmcsv","timestamp": Date.now(), "description":"start loading"});

           document.getElementById("lpmmodeldisplay").disabled=true;
           document.getElementById("loadlpmcsv").value="Load LPM Data (Loading)";

          let persontype=document.getElementById("sel_lpm").value;//lpm_hiker
          // time duration
          let ih_start = 1;//1
          let ih_stop = 12;//12;

          // number of clue files
          let count_clues=4;

          // number of contour map files
          let totalfiles=1*(ih_stop-ih_start+1)+count_clues;

          //folder of files
          let lpmfolder="/static/data/LPMdata5/"+m_scenarios[m_scenario_index]["scenario_name"]+"/"+persontype;//"LPMdata3"
          //console.log(lpmfolder);
          //load 2 types of data: contour map, trajectory
          for(let i=ih_start;i<=ih_stop;i++){
            for(let t_rank=1;t_rank<=1;t_rank++){
              // m_lpdata_con.push
              let csvfilename=lpmfolder+"/best fits/contour data csv/con_"+persontype+"bf"+t_rank.toString()+"_t"+i.toString()+".csv";
              LoadLPFromCSV_con(csvfilename,totalfiles,i-1,t_rank-1,'byhour');
            }
          }

          // clue1:t1, clue2:t2, clue12:t3, final: t4, final is the overall
          let cluenames=['final','clue1','clue2','clue12'];
          for(let i=0;i<count_clues;i++){
            let csvfilename= lpmfolder+"/clues/contour data csv/con_"+persontype+"_bf1_"+cluenames[i]+".csv";
            LoadLPFromCSV_con(csvfilename,totalfiles,i,0,'byclue');
            //console.log(csvfilename);
          }
          let csvfilename= lpmfolder+"/clues/traj_"+persontype+"_bf1.csv";
          LoadLPFromCSV_Tra_All(csvfilename,0,0);

          for(let i=0;i<count_clues;i++){
            let csvfilename= lpmfolder+"/clues/"+cluenames[i]+"index_"+persontype+"_bf1.csv";
            LoadLPFromCSV_Tra_Item(csvfilename,0,i);
            //console.log(csvfilename);
          }


          document.getElementById("lpmmodeldisplay").disabled=false;
         }



         function DisableAllGraphicLayers(){
           visualization_Contourmap_Layer.visible=false;
           visualization_Trajectories_Layer.visible=false;
           visualization_Cone_Layer.visible=false;
           temperalgraphicLayer.visible=false;
           visualization_Segmentheat_Layer.visible=false;
           graphicLayer_hit_2D.visible=false;

           graphicLayer_hit_3D.visible=false;
           graphicLayer_contour_3D.visible=false;
           graphicLayer_clue_3D.visible=false;
           graphicLayer_heightline_3D.visible=false;
         }

         function UpdateVisualization(){
           //console.log("UpdateVisualization");
           if (document.getElementById("sel_lpmodel").value=="contour"){
             // either 'byhour' or 'byclue'
             //console.log(m_lpdata_con);
             AddLPDataToContourlayer(m_visualizationtype);
             AddLPDataToContourlayer_3D(m_visualizationtype);
           }
           else if(document.getElementById("sel_lpmodel").value=="clueipp"){
             //AddCluetoInteractionImagelayer();
           }
           else if(document.getElementById("sel_lpmodel").value=="cone"){
             //AddCluetoInteractionImagelayer();
             AddLPDataToConelayer();
           }
           else if(document.getElementById("sel_lpmodel").value=="trajectories"){
             //AddCluetoInteractionImagelayer();

             AddLPDataToTrajectorylayer(m_visualizationtype);
           }
           else if(document.getElementById("sel_lpmodel").value=="segmentheat"){
             //AddCluetoInteractionImagelayer();
             AddLPDataToSegmentheatlayer(m_visualizationtype);
           }
         }


          function UpdateDronePathDisplay(pt_arr,pathcolor,lineweight,displayLayer){
            //update the drone path on pathplanninglayer

            displayLayer.removeAll();
            let path_featureset=[];
            let path_polyline=[];
            //draw all gpsdata
            //console.log(arrinput);
            //let pt_arr=arrinput;
            for(let i=0;i<pt_arr.length;i++){
              let t_graphic= new Graphic({
                geometry: {
                  type:'point',
                  latitude:pt_arr[i].lat,
                  longitude:pt_arr[i].long,
                  spatialReference:view.spatialReference
                },
                symbol:  {
                  type: "simple-marker",
                  style:"circle",
                  color: pathcolor,
                  size:12
                  }
              });
              path_featureset.push(t_graphic);

              let t_graphic_text=new Graphic ({
                geometry:{
                  type:'point',
                  latitude:pt_arr[i].lat,
                  longitude:pt_arr[i].long,
                  spatialReference:view.spatialReference
                },
                symbol:{
                  type: "text",  // autocasts as new TextSymbol()
                  color: "white",
                  haloColor: "black",
                  haloSize: "1px",
                  text: pt_arr[i].stamp,
                  xoffset: 0,
                  yoffset: 0,
                  font: {  // autocast as new Font()
                    size: 10,
                    family: "Josefin Slab",
                    weight: "bold"
                  }
                }
              });
              path_featureset.push(t_graphic_text);
              path_polyline.push([pt_arr[i].long,pt_arr[i].lat]);
            }
            //waypointstartpointarray=path_polyline[0];
            //console.log(path_featureset);
            let polylineGraphic = new Graphic({
              geometry: {
                type: "polyline",
                paths: path_polyline
              },
              symbol: {
                type: "simple-line",
                color: pathcolor,
                width: lineweight
              }
            });
            displayLayer.visible=true;
            displayLayer.add(polylineGraphic);
            displayLayer.addMany(path_featureset);
          }




         function GetPathFromCell3D_BasicCircle(geometry_2D){
           graphicsLayer3D.removeAll();
           let rings_2D=geometry_2D.geometry.rings[0];
           let center_2D=geometry_2D.geometry.extent.center;//center.x
           let rings_3D=[];
           //let height_3D=100; // UAV height default
           let decentralize=0.7;

           let rings_3DM=[];
           let rings_3DH=[];

           for(let i=0;i<rings_2D.length;++i){
             rings_3D.push([rings_2D[i][0]*0.9+center_2D.x*0.1,rings_2D[i][1]*0.9+center_2D.y*0.1,m_height_3D[0]]);
           }

           for(let i=0;i<rings_2D.length;++i){
             rings_3DM.push([rings_2D[i][0]*0.9+center_2D.x*0.1,rings_2D[i][1]*0.9+center_2D.y*0.1,m_height_3D[1]]);
           }

           for(let i=0;i<rings_2D.length;++i){
             rings_3DH.push([rings_2D[i][0]*0.9+center_2D.x*0.1,rings_2D[i][1]*0.9+center_2D.y*0.1,m_height_3D[2]]);
           }


           const polyline = {
             type: "polyline",
             paths: rings_3D
           };

           const roundTubeSymbol = {
             type: "line-3d",
             symbolLayers: [{
               type: "path",
               profile: "circle",
               material: {
                 color: m_segmentRingColor.L// [255, 156, 0]
               },
               width: 5, // the width in m
               height: 5 // the height in m
             }]
           };

           const polylineGraphic = new Graphic({
             geometry: polyline,
             symbol: roundTubeSymbol,
             spatialReference: m_selectedgraphicrect2D.geometry.spatialReference
           });

           graphicsLayer3D.add(polylineGraphic);

           const polylineM = {
             type: "polyline",
             paths: rings_3DM
           };

           const roundTubeSymbolM = {
             type: "line-3d",
             symbolLayers: [{
               type: "path",
               profile: "circle",
               material: {
                 color: m_segmentRingColor.M// [255, 156, 0]
               },
               width: 5, // the width in m
               height: 5 // the height in m
             }]
           };

           const polylineGraphicM = new Graphic({
             geometry: polylineM,
             symbol: roundTubeSymbolM,
             spatialReference: m_selectedgraphicrect2D.geometry.spatialReference
           });

           graphicsLayer3D.add(polylineGraphicM);

           const polylineH = {
             type: "polyline",
             paths: rings_3DH
           };

           const roundTubeSymbolH = {
             type: "line-3d",
             symbolLayers: [{
               type: "path",
               profile: "circle",
               material: {
                 color: m_segmentRingColor.H// [255, 156, 0]
               },
               width: 5, // the width in m
               height: 5 // the height in m
             }]
           };

           const polylineGraphicH = new Graphic({
             geometry: polylineH,
             symbol: roundTubeSymbolH,
             spatialReference: m_selectedgraphicrect2D.geometry.spatialReference
           });

           graphicsLayer3D.add(polylineGraphicH);

           return "GetPathFromCell3D_BasicCircle";
         }

         function DrawClue3D(currentClueIndex,center,clueHeight,clueColor,size=20){
           let clueinfo=m_expsetupobj.location_3D[m_exp_loc_index].clue[currentClueIndex[0]];
           //add 3D point on path
           const symbol = {
            type: "point-3d",  // autocasts as new PointSymbol3D()
            symbolLayers: [{
              type: "object",  // autocasts as new ObjectSymbol3DLayer()
              width: size,  // diameter of the object from east to west in meters
              height: size,  // height of the object in meters
              depth: size,  // diameter of the object from north to south in meters
              resource: { primitive: "sphere" },
              material: { color: clueColor }
            }]
          };
          let t_graphic3D =  new Graphic({
             geometry: {
               type: "point", // autocasts as new Point()
               x: center[0],
               y: center[1],
               z: center[2]
             },
             symbol:symbol,
             popupTemplate:{
                title: clueinfo.info,
                content:[{
                  type: "media",
                  mediaInfos: [{
                    title: "Drone2",
                    type: "image",
                    caption: "Optical camera top view, location:("+ center[0] +","+center[1]+","+center[2]+")",
                    value: {sourceURL: clueinfo.sourceURL[clueHeight]}
                  }]
                }]
              }
           });
           graphicLayer_clue_3D.add(t_graphic3D);
           document.getElementById("testImg").src=clueinfo.sourceURL[clueHeight];
         }

         function DrawCurrentClueOnPath(currentClueIndex){
           let point2D=m_expsetupobj.location_3D[m_exp_loc_index].clue[currentClueIndex[0]];
           let tindex=currentClueIndex[m_currentHeight+1];
           let point3D=m_UAVRouteHML[m_currentHeight][tindex];
           //clue on the ground
           //graphicLayer_clue_3D.removeAll();
           let in_point=new Point({
             longitude:point2D.location[0],
             latitude:point2D.location[1]
           });
           let t_graphic2D=  new Graphic({
             geometry: in_point,
             symbol:  {
                  type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                  style:"circle",
                  color: [255,255,0],//[t_mag, 0,0],
                  size:10
                },
              attributes:{
                Name:point2D.info,
                Hour:0,
                Rank:1
              },
              popupTemplate:{
                 title: point2D.info,
                 content:[{
                   type: "media",
                   mediaInfos: [{
                     title: "Drone2",
                     type: "image",
                     caption: "Optical camera top view, location:("+ in_point.latitude +","+in_point.longitude+")",
                     value: {sourceURL: point2D.sourceURL[m_currentHeight]}
                   }]
                 }]
               }
           });
           graphicLayer_clue_3D.add(t_graphic2D);

           let t_copy_graphic2D=t_graphic2D.clone();
           temperalgraphicLayer.add(t_copy_graphic2D);// this may block the  clue on the 3D map
           document.getElementById("testImg").src=point2D.sourceURL[m_currentHeight];

           //add 3D point on path
           const symbol = {
            type: "point-3d",  // autocasts as new PointSymbol3D()
            symbolLayers: [{
              type: "object",  // autocasts as new ObjectSymbol3DLayer()
              width: 20,  // diameter of the object from east to west in meters
              height: 20,  // height of the object in meters
              depth: 20,  // diameter of the object from north to south in meters
              resource: { primitive: "sphere" },
              material: { color: [255, 255, 0] }
            }]
          };
          let t_graphic3D =  new Graphic({
             geometry: {
               type: "point", // autocasts as new Point()
               x: point3D[0],
               y: point3D[1],
               z: point3D[2]
             },
             symbol:symbol,
             popupTemplate:{
                title: point2D.info,
                content:[{
                  type: "media",
                  mediaInfos: [{
                    title: "Drone2",
                    type: "image",
                    caption: "Optical camera top view, location:("+ in_point.latitude +","+in_point.longitude+")",
                    value: {sourceURL: point2D.sourceURL[m_currentHeight]}
                  }]
                }]
              }
           });
           graphicLayer_clue_3D.add(t_graphic3D);

           //draw a vertical line
           const polyline = {
             type: "polyline",
             paths: [point3D,[point3D[0],point3D[1],-100]]
           };

           const roundTubeSymbol = {
             type: "line-3d",
             symbolLayers: [{
               type: "path",
               profile: "circle",
               material: {
                 color: [156, 156, 156]// [255, 156, 0]
               },
               width: 5, // the width in m
               height: 5 // the height in m
             }]
           };

           const polylineGraphic = new Graphic({
             geometry: polyline,
             symbol: roundTubeSymbol
           });
           graphicLayer_heightline_3D.removeAll();
           graphicLayer_heightline_3D.add(polylineGraphic);

           let tcolor=Object.values(m_segmentRingColor);
           //console.log('tcolor',tcolor);
           let baselineheight=20;
           let unitHeight=(point3D[2]-baselineheight)/(3-m_currentHeight);
           let k=1;
           m_clueOnVertical3D=[point3D];
           for(let i=m_currentHeight+1;i<4;i++){
             //console.log('i',i,'k',k);
             //console.log('baselineheight+point3D[2]-unitHeight*k',point3D[2]-unitHeight*k);
             DrawRect([point3D[0],point3D[1],point3D[2]-unitHeight*k],tcolor[i],size=20);
             m_clueOnVertical3D.push([point3D[0],point3D[1],point3D[2]-unitHeight*k]);//H,M,L,B
             k=k+1;
           }

           graphicLayer_clue_3D.visible=true;
           graphicLayer_heightline_3D.visible=true;
         }

         function DrawRect(center,rectcolor,size=20){
           const symbol = {
            type: "point-3d",  // autocasts as new PointSymbol3D()
            symbolLayers: [{
              type: "object",  // autocasts as new ObjectSymbol3DLayer()
              width: size,  // diameter of the object from east to west in meters
              height: 2,  // height of the object in meters
              depth: size,  // diameter of the object from north to south in meters
              resource: { primitive: "diamond" },
              material: { color: rectcolor }
            }]
          };
          let t_graphic3D =  new Graphic({
             geometry: {
               type: "point", // autocasts as new Point()
               x: center[0],
               y: center[1],
               z: center[2]
             },
             symbol:symbol
           });
           graphicLayer_heightline_3D.add(t_graphic3D);
         }

         function GetCluePointsOnPath(){
           //high
           let tarrH=[];
           for(let i=0; i<m_expsetupobj.location_3D[m_exp_loc_index].clue.length; ++i){
             let minLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[0]-m_UAVRouteHML[0][0][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[1]-m_UAVRouteHML[0][0][1],2);
             let minj=0;
             for(let k=0;k<m_UAVRouteHML[0].length;k++){
               let tLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[0]-m_UAVRouteHML[0][k][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[1]-m_UAVRouteHML[0][k][1],2);
               if(tLen<minLen){
                 minLen=tLen;
                 minj=k;
               }
             }
             m_expsetupobj.location_3D[m_exp_loc_index].clue[i].H3D=m_UAVRouteHML[0][minj];
             m_expsetupobj.location_3D[m_exp_loc_index].clue[i].H3D_index=minj;
             tarrH.push([i,minj]);
           }
           //mid
           let tarrM=[];
           for(let i=0; i<m_expsetupobj.location_3D[m_exp_loc_index].clue.length; ++i){
             let minLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[0]-m_UAVRouteHML[1][0][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[1]-m_UAVRouteHML[1][0][1],2);
             let minj=0;
             for(let k=0;k<m_UAVRouteHML[1].length;k++){
               let tLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[0]-m_UAVRouteHML[1][k][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[1]-m_UAVRouteHML[1][k][1],2);
               if(tLen<minLen){
                 minLen=tLen;
                 minj=k;
               }
             }
             m_expsetupobj.location_3D[m_exp_loc_index].clue[i].M3D=m_UAVRouteHML[1][minj];
             m_expsetupobj.location_3D[m_exp_loc_index].clue[i].M3D_index=minj;
             tarrM.push([i,minj]);
           }
           //low
           let tarrL=[];
           for(let i=0; i<m_expsetupobj.location_3D[m_exp_loc_index].clue.length; ++i){
             let minLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[0]-m_UAVRouteHML[2][0][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[1]-m_UAVRouteHML[2][0][1],2);
             let minj=0;
             for(let k=0;k<m_UAVRouteHML[2].length;k++){
               let tLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[0]-m_UAVRouteHML[2][k][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].location[1]-m_UAVRouteHML[2][k][1],2);
               if(tLen<minLen){
                 minLen=tLen;
                 minj=k;
               }
             }
             m_expsetupobj.location_3D[m_exp_loc_index].clue[i].L3D=m_UAVRouteHML[2][minj];
             m_expsetupobj.location_3D[m_exp_loc_index].clue[i].L3D_index=minj;
             tarrL.push([i,minj]);
           }
           m_unfoundClues=[];

           for(let i=0; i<m_expsetupobj.location_3D[m_exp_loc_index].clue.length; ++i){
             m_expsetupobj.location_3D[m_exp_loc_index].clue[i].HIndex=tarrH[i][1];
             m_expsetupobj.location_3D[m_exp_loc_index].clue[i].MIndex=tarrM[i][1];
             m_expsetupobj.location_3D[m_exp_loc_index].clue[i].LIndex=tarrL[i][1];
             m_unfoundClues.push([i,tarrH[i][1],tarrM[i][1],tarrL[i][1]]);
           }
           m_unfoundClues = m_unfoundClues.slice().sort(function(a,b){return b[m_currentHeight+1]-a[m_currentHeight+1]});
           //console.log("tarrH",tarrH,"tarrM",tarrM,"tarrL",tarrL);
           //let sortedH = tarrH.slice().sort(function(a,b){return b[1]-a[1]});
           //let sortedM = tarrM.slice().sort(function(a,b){return b[1]-a[1]});
           //let sortedL = tarrL.slice().sort(function(a,b){return b[1]-a[1]});
           //console.log("sortedH",sortedH,"sortedM",sortedM,"sortedL",sortedL);

           //order
           //console.log(m_expsetupobj.location_3D[m_exp_loc_index]);

         }
         function GetCluePointsOnPath3D(){

           //high
           let tarrH=[];
           for(let i=0; i<m_unfoundClues.length; ++i){
             let tindex=m_unfoundClues[i][0];
             let minLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[0]-m_UAVRouteHML[0][0][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[1]-m_UAVRouteHML[0][0][1],2);
             let minj=0;
             for(let k=0;k<m_UAVRouteHML[0].length;k++){
               let tLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[0]-m_UAVRouteHML[0][k][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[1]-m_UAVRouteHML[0][k][1],2);
               if(tLen<minLen){
                 minLen=tLen;
                 minj=k;
               }
             }
             m_unfoundClues[i][1]=minj;
             //tarrH.push([tindex,minj]);
           }
           //mid
           for(let i=0; i<m_unfoundClues.length; ++i){
             let tindex=m_unfoundClues[i][0];
             let minLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[0]-m_UAVRouteHML[1][0][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[1]-m_UAVRouteHML[1][0][1],2);
             let minj=0;
             for(let k=0;k<m_UAVRouteHML[1].length;k++){
               let tLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[0]-m_UAVRouteHML[1][k][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[1]-m_UAVRouteHML[1][k][1],2);
               if(tLen<minLen){
                 minLen=tLen;
                 minj=k;
               }
             }
             m_unfoundClues[i][2]=minj;
           }
           //low
           for(let i=0; i<m_unfoundClues.length; ++i){
             let tindex=m_unfoundClues[i][0];
             let minLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[0]-m_UAVRouteHML[2][0][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[1]-m_UAVRouteHML[2][0][1],2);
             let minj=0;
             for(let k=0;k<m_UAVRouteHML[2].length;k++){
               let tLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[0]-m_UAVRouteHML[2][k][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[1]-m_UAVRouteHML[2][k][1],2);
               if(tLen<minLen){
                 minLen=tLen;
                 minj=k;
               }
             }
             m_unfoundClues[i][3]=minj;
           }
           m_unfoundClues = m_unfoundClues.slice().sort(function(a,b){return b[m_currentHeight+1]-a[m_currentHeight+1]});
         }

         function UpdateCluePointsOnPath(){
           let tarrL=[];
           for(let i=0; i<m_unfoundClues.length; ++i){
             let tindex=m_unfoundClues[i][0];
             let minLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[0]-m_UAVRouteHML[m_currentHeight+1][0][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[1]-m_UAVRouteHML[m_currentHeight+1][0][1],2);
             let minj=0;
             for(let k=0;k<m_UAVRouteHML[m_currentHeight+1].length;k++){
               let tLen=Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[0]-m_UAVRouteHML[m_currentHeight+1][k][0],2)+Math.pow(m_expsetupobj.location_3D[m_exp_loc_index].clue[tindex].location[1]-m_UAVRouteHML[m_currentHeight+1][k][1],2);
               if(tLen<minLen){
                 minLen=tLen;
                 minj=k;
               }
             }
             m_unfoundClues[i][m_currentHeight+1]=minj;
           }
           m_unfoundClues = m_unfoundClues.slice().sort(function(a,b){return b[m_currentHeight+1]-a[m_currentHeight+1]});
         }

         function CutPassedPath(height,center){
           // detect the nearest point on path
           //m_UAVRouteHML[height];
           let minLen=Math.pow(center[0]-m_UAVRouteHML[height][0][0],2)+Math.pow(center[1]-m_UAVRouteHML[height][0][1],2);
           let minj=0;
           //console.log(m_UAVRouteHML);
           for(let k=0;k<m_UAVRouteHML[height].length;k++){
             let tLen=Math.pow(center[0]-m_UAVRouteHML[height][k][0],2)+Math.pow(center[1]-m_UAVRouteHML[height][k][1],2);
             if(tLen<minLen){
               minLen=tLen;
               minj=k;
             }
           }
           m_UAVRouteHML[height] = m_UAVRouteHML[height].slice(minj+1);
         }

         function GetPathFromCell3D(geometry_2D,urlObj){
           // get water layer
           // get terrain layer
           //console.log(geometry_2D);
           let contourarr=[];
           for (let i=0;i<arr_featureset.length;i++){
             contourarr.push(arr_featureset[i].geometry.rings[0]);
           }
           let t_index=parseInt(geometry_2D.attributes.polygonindex);
           let indexarr=[t_index];

           let voronoiarr=[];
           let markspatialreference="epsg3857";
           if(epsg4326_voronoiarr.length>1){
             markspatialreference="epsg4326";
             for(let i=0;i<epsg4326_voronoiarr.length;i++){
               voronoiarr.push([]);
             }
             for(let j=0;j<indexarr.length;j++){
               voronoiarr[indexarr[j]]=epsg4326_voronoiarr[indexarr[j]];
             }
             //voronoiarr=epsg4326_voronoiarr;
           }
           else{
             markspatialreference="epsg3857";
             for(let i=0;i<allpolygons.length;i++){
               //voronoiarr.push(allpolygons[i].geometry.rings[0]);
               voronoiarr.push([]);
             }
             for(let j=0;j<indexarr.length;j++){
               voronoiarr[indexarr[j]]=allpolygons[indexarr[j]].geometry.rings[0];
             }
           }
           let URL = "{% url 'getPathFromArea' %}";
           //console.log("urlObj",urlObj);
           resolution=0.0005;
           baseline=-100;
           let startpt = [];//request.POST.get('startpt')
           let direction = [];//request.POST.get('direction')
           let data = {
                   csrfmiddlewaretoken: '{{ csrf_token }}',
                   'contourarr': JSON.stringify(contourarr),
                   'voronoiarr': JSON.stringify(voronoiarr),
                   'terrainobj':JSON.stringify(urlObj),
                   'indexarr': JSON.stringify(indexarr),
                   'resolution': JSON.stringify(resolution),
                   'baseline':JSON.stringify(baseline),
                   'startpt':JSON.stringify(startpt),
                   'direction':JSON.stringify(direction),
                   'spatialReference': markspatialreference
                  };
           $.post(URL, data, function(response){
             let res=JSON.parse(response);
               if(res.flag == 'success'){
                 //m_UAVRouteHML=[res.path3DH[indexarr[0]],res.path3DM[indexarr[0]],res.path3DL[indexarr[0]]];
                 m_UAVRouteHML=[res.path3DH,res.path3DM,res.path3DL];
                 //AdaptUAVRouteHMLToBasicHeight();
                 SetupClueLocation(m_UAVRouteHML[2]);
                 //console.log(m_UAVRouteHML);
                 m_passPath=[];
                 m_searchFinish=false;
                 GetCluePointsOnPath();
                 graphicsLayer3D_UAVPath.removeAll();
                 DrawPath(m_UAVRouteHML[0],[0, 156, 255],geometry_2D.geometry.spatialReference);
                 //DrawPath(res.path3DM[indexarr[0]],[156, 156, 156],geometry_2D.geometry.spatialReference);
                 //DrawPath(res.path3DL[indexarr[0]],[80, 80, 80],geometry_2D.geometry.spatialReference);

                }
               else{ alert(response); }
           });
           return "GetPathFromCell3D";
         }
         function AdaptUAVRouteHMLToBasicHeight(){
           //m_height_3D=[100,200,300];
           //m_UAVRouteHML;
         }

         function GetUpdatedPathFromCell3D(geometry_2D,urlObj,baseline=-100, resolution=0.0005, startpt=[],direction=[]){
           // get water layer
           // get terrain layer
           //console.log(geometry_2D);
           let contourarr=[];
           for (let i=0;i<arr_featureset.length;i++){
             contourarr.push(arr_featureset[i].geometry.rings[0]);
           }
           let t_index=parseInt(geometry_2D.attributes.polygonindex);
           let indexarr=[t_index];

           let voronoiarr=[];
           let markspatialreference="epsg3857";
           if(epsg4326_voronoiarr.length>1){
             markspatialreference="epsg4326";
             for(let i=0;i<epsg4326_voronoiarr.length;i++){
               voronoiarr.push([]);
             }
             for(let j=0;j<indexarr.length;j++){
               voronoiarr[indexarr[j]]=epsg4326_voronoiarr[indexarr[j]];
             }
             //voronoiarr=epsg4326_voronoiarr;
           }
           else{
             markspatialreference="epsg3857";
             for(let i=0;i<allpolygons.length;i++){
               //voronoiarr.push(allpolygons[i].geometry.rings[0]);
               voronoiarr.push([]);
             }
             for(let j=0;j<indexarr.length;j++){
               voronoiarr[indexarr[j]]=allpolygons[indexarr[j]].geometry.rings[0];
             }
           }

           // draw a 2D line to divide the searched area vs unsearched area

           let URL = "{% url 'getUpdatedPathFromArea' %}";

           let data = {
                   csrfmiddlewaretoken: '{{ csrf_token }}',
                   'contourarr': JSON.stringify(contourarr),
                   'voronoiarr': JSON.stringify(voronoiarr),
                   'terrainobj':JSON.stringify(urlObj),
                   'indexarr': JSON.stringify(indexarr),
                   'resolution': JSON.stringify(resolution),
                   'baseline':JSON.stringify(baseline),
                   'startpt':JSON.stringify(startpt),
                   'direction':JSON.stringify(direction),
                   'passpath':JSON.stringify(m_passPath),
                   'spatialReference': markspatialreference
                  };
           $.post(URL, data, function(response){
             let res=JSON.parse(response);
               if(res.flag == 'success'){

                 m_UAVRouteHML[m_currentHeight]=res.path3D;
                 UpdateCluePointsOnPath();
                 let outSpatialReference = new SpatialReference({
                   wkid: 4326
                 });
                 graphicsLayer3D_UAVPath.removeAll();
                 DrawPath(m_passPath,[80,80,80],outSpatialReference,4);
                 let tline=[m_passPath[m_passPath.length-1],m_UAVRouteHML[m_currentHeight][0]];
                 DrawPath(tline,[80,80,80],outSpatialReference,4);
                 let tcolor=Object.values(m_segmentRingColor);
                 DrawPath(m_UAVRouteHML[m_currentHeight],tcolor[m_currentHeight],outSpatialReference);

                }
               else{ alert(response); }
           });
           return "GetPathFromCell3D";
         }

         function DrawPath(path3D,color3D,spatialReference3D,size=3){
           const polyline = {
             type: "polyline",
             paths: path3D
           };

           const roundTubeSymbol = {
             type: "line-3d",
             symbolLayers: [{
               type: "path",
               profile: "circle",
               material: {
                 color: color3D
               },
               width: size, // the width in m
               height: size // the height in m
             }]
           };

           const polylineGraphic = new Graphic({
             geometry: polyline,
             symbol: roundTubeSymbol,
             spatialReference: spatialReference3D
           });

           graphicsLayer3D_UAVPath.add(polylineGraphic);
         }

         // update path when lower or higher the path
         function shuffleArray(array) {
              for (let i = array.length - 1; i > 0; i--) {
                  let j = Math.floor(Math.random() * (i + 1));
                  let temp = array[i];
                  array[i] = array[j];
                  array[j] = temp;
              }
              return array;
          }
         function SetupClueLocation(path){
           //console.log(path);
           // randomize the clue location based on the generated path, which is at high location.
           let tlen=path.length;
           let tset=[];
           let unitlen=Math.floor(tlen/(m_exp_location.clue.length+1));

           // divide the path into number of clues , then ranomize each clue in each range
           for(let i=0;i<m_exp_location.clue.length;i++){
             let tindex=Math.floor((i+0.5+Math.random())*unitlen);
             if(tindex>tlen-1){
               tindex=tlen-1;
             }
             tset.push(tindex);
             //console.log(i,tindex);
           }
           //console.log(tset);

           let targetindex=tset.length -1- Math.floor(Math.random() * 3);
           //console.log(targetindex);
           let tlast=tset[tset.length -1];
           tset[tset.length -1]=tset[targetindex];
           tset[targetindex]=tlast;
           //console.log(tset);

           let res_arr=shuffleArray(tset.slice(0,tset.length-1));
           res_arr.push(tlast);
           //console.log(res_arr);

           for(let i=0;i<m_exp_location.clue.length;i++){
             m_exp_location.clue[i].location=path[res_arr[i]];
             //console.log(res_arr[i]);
           }
         }

         function DisplayUAVPath_3D(){

          let outSpatialReference = new SpatialReference({
                wkid: 4326
          });
          projection.load().then(function() {

            let geometry_2D=new Graphic({
              geometry:{
                   type:"polygon",
                   rings:m_selectedgraphicrect2D.geometry.rings,
                   spatialReference:view.spatialReference
               },
               attributes:m_selectedgraphicrect2D.attributes
            });
            geometry_2D.geometry = projection.project(geometry_2D.geometry, outSpatialReference);
            m_geometry_2D=geometry_2D;
            //let t_extent.xmin={-8922952.933898335%2C4461476.466949167%2C-8844681.416934315%2C4539747.983913187}

            GetPathFromCell3D_BasicCircle(geometry_2D);

            //get extent
            let selectedExtent=m_selectedgraphicrect2D.geometry.extent;
            let fullExtent=view.extent;

            let tWidthScale=selectedExtent.width/fullExtent.width;
            let tHeightScale=selectedExtent.height/fullExtent.height;

            let pixW=parseInt(tWidthScale*view.width);
            let pixH=parseInt(tHeightScale*view.height);


            //console.log(geometry_2D);
            landcoverlayer.fetchImage(geometry_2D.geometry.extent,pixW,pixH).then(function(tres){
              let urlObj={
                xmin:geometry_2D.geometry.extent.xmin,
                xmax:geometry_2D.geometry.extent.xmax,
                ymin:geometry_2D.geometry.extent.ymin,
                ymax:geometry_2D.geometry.extent.ymax,
                width:geometry_2D.geometry.extent.width,
                height:geometry_2D.geometry.extent.height,
                pixW:pixW,
                pixH:pixH,
                urlImage:tres.src
              }
              m_urlObj=urlObj;

              let tpath=GetPathFromCell3D(geometry_2D,urlObj);
              //document.getElementById("testImg").src=tres.src;

            });


          });
         }
         function LoadLPMData(){
           m_lpdata_con=[];
           m_lpdata_trial=[];
           m_lpdata_trajectory=[];
           m_lpdata_tra_colormap=[];

           ClearAll();

           // spatial experiment, the heat map is not changing based on hours.
           // set hour=11
           let spatial_timeslot=m_exp_variables.hour;

           // number of clue files
           let count_clues=4;
           let count_trajectory=count_clues+1;

           //folder of files, SAR EXPERIMENT SPATIAL
           let lpmfolder="/static/data/LPMEXPS2/"+m_exp_location.name;

           // clue1:t1, clue2:t2, clue12:t3, final: t4, final is the overall
           let cluenames=['final','clue1','clue2','clue12'];
           let csvfilename=lpmfolder;

           // contour map at time 11
           csvfilename=lpmfolder+"/con_t"+spatial_timeslot.toString()+".csv";
           LoadLPFromCSV_con(csvfilename,count_clues+1,spatial_timeslot,'byhour');

           // clue contour map
           for(let i=0;i<count_clues;i++){
             csvfilename= lpmfolder+"/con_"+cluenames[i]+".csv";
             LoadLPFromCSV_con(csvfilename,count_clues+1,i,'byclue');
           }

        }
         function DisplayHeatmap(t_type = "byhour"){
           let m_exp_variables={
             hour:11
           };

           visualization_Contourmap_Layer.removeAll();
           // lost person model
           arr_featureset=[];
           if(m_lpdata_con == null){
             return;
           }
           //console.log(m_lpdata_con);
           let t_data_con,t_hour;

           if (t_type == "byclue"){
             t_hour=document.getElementById("myClues").value;
           }
           else if(t_type == "byhour"){
             t_hour=m_exp_variables.hour;
           }
           //console.log(m_lpdata_con);

           arr_heatpoints=[];

           let t_break=m_lpdata_con.length;
           let i=0;
           while(i<t_break){
             if(m_lpdata_con[i]['type']==t_type && m_lpdata_con[i]['hour']==t_hour){
               arr_heatpoints=m_lpdata_con[i]['data'];
                break;
             }
             i++;
           }

           let t_rings=[];//
           let all_paths=[];
           let t_startprobability=arr_heatpoints[0][0];

           let col3 = arr_heatpoints.map(function(value,index) { return value[0]; });
           let t_min = Math.min(...col3);
           let t_max=Math.max(...col3);
           let t_range=t_max-t_min;

           let t_mag=(t_startprobability-t_min)/t_range;

           let markerSymbol = {
             type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
             color: [226, 119, 40],
             outline: {
               style:"none"
             }
           };

          let fillSymbol= {
            type: "simple-fill", // autocasts as SimpleFillSymbol
            color: [226, 119, 40],
            outline: { // autocasts as SimpleLineSymbol
              style:"none"
            }
          };
          let t_distance=0.0001;//define as a circle
          let t_len=0;
          let t_index=0;
          let t_oppacity=3;//0.8

           arr_heatpoints.map(function(item){
             t_len=t_rings.length-1;
             if(item[0]==t_startprobability){
               if(t_len>3){
                 if(t_distance<((item[1]-t_rings[t_len][0])*(item[1]-t_rings[t_len][0])+ (item[2]-t_rings[t_len][1])*(item[2]-t_rings[t_len][1]))){
                   t_rings.push(t_rings[0]);
                   let tmulpt=new Polygon({
                      rings: t_rings.reverse(),
                      spatialReference: { wkid: 4326 }
                    });
                    t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);
                    t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

                    fillSymbol.color=t_rgb;
                    let polylineGraphic = new Graphic({
                      geometry: tmulpt,
                      symbol: fillSymbol
                    });
                     arr_featureset.push(polylineGraphic);
                     t_index=t_index+1;

                   t_rings=[];
                 }
               }
             }
             else{
               t_rings.push(t_rings[0]);
               let tmulpt=new Polygon({
                  rings: t_rings.reverse(),
                  spatialReference: { wkid: 4326 }
                });
                t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);
                t_rgb.push(t_oppacity*t_mag+0.3);//oppacity
                fillSymbol.color=t_rgb;
                let polylineGraphic = new Graphic({
                  geometry: tmulpt, // Add the geometry created in step 4
                  symbol: fillSymbol
                });
                 arr_featureset.push(polylineGraphic);//t_graphic

                 t_index=t_index+1;

                 t_rings=[];
                 t_startprobability=item[0];
                 t_mag=(t_startprobability-t_min)/t_range;
             }
             t_rings.push(item.slice(1));
           });
           if(t_rings.length>0){
             t_rings.push(t_rings[0]);
            let tmulpt=new Polygon({
              rings: t_rings.reverse(),
              spatialReference: { wkid: 4326 }
            });
            t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
            t_rgb.push(t_oppacity*t_mag+0.3);//oppacity
            fillSymbol.color=t_rgb;
            let polylineGraphic = new Graphic({
              geometry: tmulpt,
              symbol: fillSymbol
            });
             arr_featureset.push(polylineGraphic);
             t_index=t_index+1;
             t_rings=[];
           }
           //console.log(arr_featureset);
           visualization_Contourmap_Layer.addMany(arr_featureset);
           visualization_Contourmap_Layer.visible=true;

         }
         function DisplayHeatmap_3D(t_type = "byhour"){
           //console.log(m_lpdata_con);
           graphicLayer_contour_3D.removeAll();
           let arr_featureset_3D=[];
           if(m_lpdata_con == null){
             //console.log(m_lpdata_con);
             return;
           }

           let t_data_con;
           let t_hour=11;

           if (t_type == "byclue"){
             t_hour=document.getElementById("myClues").value;
           }
           else if(t_type == "byhour"){
             t_hour=11;
           }

           let arr_heatpoints_3D=[];

           let t_break=m_lpdata_con.length;
           let i=0;
           while(i<t_break){
             if(m_lpdata_con[i]['type']==t_type && m_lpdata_con[i]['hour']==t_hour){
               arr_heatpoints_3D=m_lpdata_con[i]['data'];
                break;
             }
             i++;
           }
           //console.log(arr_heatpoints_3D);
           //loop to find rings
           let t_rings=[];//
           let all_paths=[];
           let t_startprobability=arr_heatpoints_3D[0][0];

           let col3 = arr_heatpoints_3D.map(function(value,index) { return value[0]; });
           let t_min = Math.min(...col3);
           let t_max=Math.max(...col3);
           let t_range=t_max-t_min;

           let t_mag=(t_startprobability-t_min)/t_range;

           let markerSymbol = {
             type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
             color: [226, 119, 40],
             outline: {
               style:"none"
             }
           };
          let fillSymbol= {
            type: "simple-fill", // autocasts as SimpleFillSymbol
            color: [226, 119, 40],
            outline: { // autocasts as SimpleLineSymbol

              style:"none"
            }
          };
          let t_distance=0.0001;//define as a circle
          let t_len=0;
          let t_index=0;
          let t_oppacity=3;//0.8

           arr_heatpoints_3D.map(function(item){
             t_len=t_rings.length-1;
             if(item[0]==t_startprobability){
               if(t_len>3){
                 if(t_distance<((item[1]-t_rings[t_len][0])*(item[1]-t_rings[t_len][0])+ (item[2]-t_rings[t_len][1])*(item[2]-t_rings[t_len][1]))){
                   //console.log((item[1]-t_rings[0][0])*(item[1]-t_rings[0][0])+ (item[2]-t_rings[0][1])*(item[2]-t_rings[0][1]));
                   // if two points are two far away, define them as different circles
                   t_rings.push(t_rings[0]);
                   let tmulpt=new Polygon({
                      rings: t_rings.reverse(),//[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
                      spatialReference: { wkid: 4326 }
                    });
                    if (m_colormap==0){
                      t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
                    }
                    else if (m_colormap==1){
                      t_rgb=hslToRgb(0.2*(1-t_mag), 1, 1-0.5*t_mag);//red:0, yellow:0.2
                    }
                    else{
                      t_rgb=hslToRgb(0.6, 1, 1-0.5*t_mag);//blue:0.6
                    }
                    t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

                    fillSymbol.color=t_rgb;
                    let polylineGraphic = new Graphic({
                      geometry: tmulpt, // Add the geometry created in step 4
                      symbol: fillSymbol
                    });
                     arr_featureset_3D.push(polylineGraphic);//t_graphic
                     t_index=t_index+1;

                   t_rings=[];
                 }
               }
             }
             else{
               //ori:t_rings.push(t_rings[t_rings.length-1]);
               t_rings.push(t_rings[0]);
               //console.log(t_rings);

               let tmulpt=new Polygon({
                  rings: t_rings.reverse(),//[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
                  spatialReference: { wkid: 4326 }
                });
                if (m_colormap==0){
                  t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
                }
                else if (m_colormap==1){
                  t_rgb=hslToRgb(0.2*(1-t_mag), 1, 1-0.5*t_mag);//red:0, yellow:0.2
                }
                else{
                  t_rgb=hslToRgb(0.6, 1, 1-0.5*t_mag);//blue:0.6
                }
                t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

                fillSymbol.color=t_rgb;
                let polylineGraphic = new Graphic({
                  geometry: tmulpt, // Add the geometry created in step 4
                  symbol: fillSymbol
                });
                 arr_featureset_3D.push(polylineGraphic);//t_graphic
                 t_index=t_index+1;

                 t_rings=[];
                 t_startprobability=item[0];
                 t_mag=(t_startprobability-t_min)/t_range;
             }
             t_rings.push(item.slice(1));
           });
           if(t_rings.length>0){

             //ori:t_rings.push(t_rings[t_rings.length-1]);
             t_rings.push(t_rings[0]);
             //console.log(t_rings);

             let tmulpt=new Polygon({
                rings: t_rings.reverse(),//[[view.extent.xmin,view.extent.ymax],[view.extent.xmax,view.extent.ymax]],
                spatialReference: { wkid: 4326 }
              });
              if (m_colormap==0){
                t_rgb=hslToRgb(1-t_mag, 1, 1-0.6*t_mag);//rainbow
              }
              else if (m_colormap==1){
                t_rgb=hslToRgb(0.2*(1-t_mag), 1, 1-0.5*t_mag);//red:0, yellow:0.2
              }
              else{
                t_rgb=hslToRgb(0.6, 1, 1-0.5*t_mag);//blue:0.6
              }
              t_rgb.push(t_oppacity*t_mag+0.3);//oppacity

              fillSymbol.color=t_rgb;
              let polylineGraphic = new Graphic({
                geometry: tmulpt, // Add the geometry created in step 4
                symbol: fillSymbol
              });
               arr_featureset_3D.push(polylineGraphic);//t_graphic
               t_index=t_index+1;

               t_rings=[];
           }
           //console.log(arr_featureset_3D);
           graphicLayer_contour_3D.addMany(arr_featureset_3D);
           graphicLayer_contour_3D.visible=true;

         }

         function DisplayClue3D(center3D,rectcolor){
           const symbol = {
            type: "point-3d",  // autocasts as new PointSymbol3D()
            symbolLayers: [{
              type: "object",  // autocasts as new ObjectSymbol3DLayer()
              width: 10,  // diameter of the object from east to west in meters
              height: 20,  // height of the object in meters
              depth: 10,  // diameter of the object from north to south in meters
              resource: { primitive: "sphere" },
              material: { color: rectcolor }
            }]
          };
          let t_graphic =  new Graphic({
            geometry: {
              type: "point", // autocasts as new Point()
              x: center3D[0],
              y: center3D[1],
              z: center3D[2]
            },
            symbol:symbol
          });
          graphicLayer_clue_3D.add(t_graphic);
         }

         function DisplayAllClue_3D(obj){
           //console.log("obj",obj);
           //console.log("obj_clue",obj_clue);
           // 1 target, 3 clues, 3 distractor
           graphicLayer_clue_3D.removeAll();
           //target
           let in_point=new Point({
                   longitude:obj.clue[0].location[0],
                   latitude:obj.clue[0].location[1]
                 });

           let t_graphic1=  new Graphic({
             geometry: in_point,
             symbol:  {
                  type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
                  style:"circle",
                  color: [getRandomInt(255), getRandomInt(255), getRandomInt(255)],//[t_mag, 0,0],
                  size:20
                },
              attributes:{
                Name:"Target",
                Hour:0,
                Rank:1
              },
              popupTemplate:{
                 title: obj.clue[0].info,
                 content:[{
                   type: "media",
                   mediaInfos: [{
                     title: "Drone2",
                     type: "image",
                     caption: "Optical camera top view, location:("+ in_point.latitude +","+in_point.longitude+")",
                     value: {sourceURL: obj.clue[0].sourceURL[m_currentHeight]}
                   }]
                 }]
               }
           });
           graphicLayer_clue_3D.add(t_graphic1);

           let t_clueobj3={
              cluephotoid: "4",
              detail: "Camera top view",
              flag: "success",
              name: "Drone1",
              url: "/media/uploads/clue.png",
           };

           // 3 clues 1-4
           for (let i=1;i<5;i++){
             let in_point=new Point({
               longitude:obj.clue[i].location[0],
               latitude:obj.clue[i].location[1]
             });

            let t_graphic =  new Graphic({
               geometry: in_point,
               symbol:  {
                 type: "picture-marker",  // autocasts as new PictureMarkerSymbol()
                 url: "{% static 'img/clue2.png' %}",//user.png
                 width: "32px",
                 height: "32px"
               },
               popupTemplate:{
                  title: "Clue",
                  content:[{
                    type: "media",
                    mediaInfos: [{
                      title: obj.clue[i].info,
                      type: "image",
                      caption: "location: ("+ in_point.longitude +","+in_point.latitude+")",
                      value: {sourceURL: obj.clue[i].sourceURL[m_currentHeight]}
                    }]
                  }]
                }
             });
             graphicLayer_clue_3D.add(t_graphic);
           }

           // 3 clues 1-4
           for (let i=5;i<9;i++){
             let in_point=new Point({
               longitude:obj.clue[i].location[0],
               latitude:obj.clue[i].location[1]
             });

            let t_graphic =  new Graphic({
               geometry: in_point,
               symbol:  {
                 type: "picture-marker",  // autocasts as new PictureMarkerSymbol()
                 url: "{% static 'img/pass.png' %}",//user.png
                 width: "32px",
                 height: "32px"
               },
               popupTemplate:{
                  title: "To be identified",
                  content:[{
                    type: "media",
                    mediaInfos: [{
                      title: obj.clue[i].info,
                      type: "image",
                      caption: "location: ("+ in_point.longitude +","+in_point.latitude+")",
                      value: {sourceURL: obj.clue[i].sourceURL[m_currentHeight]}
                    }]
                  }]
                }
             });
             graphicLayer_clue_3D.add(t_graphic);
           }

          //graphicLayer_clue_3D.addMany(arr_featureset_3D);
          //console.log(m_expsetupobj.location_3D[m_exp_loc_index].clue);
           for(let i=0;i<m_expsetupobj.location_3D[m_exp_loc_index].clue.length;++i){
             DisplayClue3D(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].H3D,m_segmentRingColor.H);
             DisplayClue3D(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].M3D,m_segmentRingColor.M);
             DisplayClue3D(m_expsetupobj.location_3D[m_exp_loc_index].clue[i].L3D,m_segmentRingColor.L);
           }
           graphicLayer_clue_3D.visible=true;
         }

         function DisplayUAVPosition_3D(cetner){
           const point = {
             type: "point", // autocasts as new Point()
             x: cetner[0],
             y: cetner[1],
             z: cetner[2]
           };

           const markerSymbol = {
             type: "simple-marker", // autocasts as new SimpleMarkerSymbol()
             color: [226, 119, 40],
             outline: {
               // autocasts as new SimpleLineSymbol()
               color: [255, 255, 255],
               width: 2
             }
           };

           const dronesymbol = {
             type: "point-3d",
             symbolLayers: [
               {
                 type: "object",
                 height: 7,
                 resource: {
                   href: "{% static 'img/Dronedraft.gltf' %}"//"./tent.glb"
                 }
               }
             ]
           };

           const pointGraphic = new Graphic({
             geometry: point,
             symbol: dronesymbol//markerSymbol
           });
           graphicsLayer3D_point.removeAll();
           graphicsLayer3D_point.add(pointGraphic);
         }

         function UpdateDroneLocationTimer3D(e){
           //m_currentHeight=0;//0,1,2
           let nmax=m_UAVRouteHML[m_currentHeight].length-1;

           if(m_step>nmax){
             DisplayUAVPosition_3D(m_UAVRouteHML[m_currentHeight][m_UAVRouteHML[m_currentHeight].length-1]);
             clearInterval(timerid3d);
             m_DroneUpdate3D=true;
             m_searchFinish=true;
             document.getElementById("bt_updateuavpostion").innerHTML='Search';
             return;
           }
           //console.log(currentIndex);
           let currentIndex=m_step%nmax;
           let center=m_UAVRouteHML[m_currentHeight][currentIndex];

           m_step=m_step+1;
           if(currentIndex%5==0){
             DisplayUAVPosition_3D(center);
           }
           m_passPath.push(center);

           // if the clue is on the path, then pop the clue
           //m_unfoundClues;//[[i,H,M,L],[i,H,M,L],[i,H,M,L],[i,H,M,L]]
           if(m_unfoundClues.length>0){
             let tindex=m_unfoundClues[m_unfoundClues.length-1][m_currentHeight+1];
             //console.log(m_currentHeight,currentIndex,tindex);
             if(currentIndex>=tindex){
               DisplayUAVPosition_3D(center);
               clearInterval(timerid3d);
               m_DroneUpdate3D=true;
               DrawCurrentClueOnPath(m_unfoundClues[m_unfoundClues.length-1]);//m_unfoundClues[i][0] is the clue_index
               //console.log(m_clueOnVertical3D);
               document.getElementById("bt_updateuavpostion").innerHTML='Search';
               //m_UAVRouteHML[m_currentHeight]=m_UAVRouteHML[m_currentHeight].slice(currentIndex);
               //m_step=0;
               m_currentClue=m_unfoundClues.pop();

               let clueinfo=m_expsetupobj.location_3D[m_exp_loc_index].clue[m_currentClue[0]];
               document.getElementById("searchResults").innerHTML="UAV: The object is a "+clueinfo.info+".";
               m_clueOnVertical3DOffset=0;
               //console.log(m_unfoundClues,m_currentHeight,m_currentClue);
             }
           }

         }
         function raiseUAVPath_3D(){
           /*
           draw a line on the 3D map
           boundary of height: current height [h,m,l]~0
           option of height change:
           */
           if(m_clueOnVertical3DOffset>0){
             m_clueOnVertical3DOffset=m_clueOnVertical3DOffset-1;
             DisplayUAVPosition_3D(m_clueOnVertical3D[m_clueOnVertical3DOffset]);

             document.getElementById("testImg").src=m_expsetupobj.location_3D[m_exp_loc_index].clue[m_currentClue[0]].sourceURL[m_currentHeight+m_clueOnVertical3DOffset];

             let clueinfo=m_expsetupobj.location_3D[m_exp_loc_index].clue[m_currentClue[0]];
             document.getElementById("searchResults").innerHTML="UAV: The object is a "+clueinfo.info+".";
           }
           //console.log(m_clueOnVertical3DOffset);
         }
         function lowerUAVPath3D(){
           if(m_clueOnVertical3DOffset<m_clueOnVertical3D.length-1){
             m_clueOnVertical3DOffset=m_clueOnVertical3DOffset+1;
             DisplayUAVPosition_3D(m_clueOnVertical3D[m_clueOnVertical3DOffset]);
             DrawClue3D(m_currentClue,m_clueOnVertical3D[m_clueOnVertical3DOffset],m_currentHeight+m_clueOnVertical3DOffset,[255,255,0],25);

             let clueinfo=m_expsetupobj.location_3D[m_exp_loc_index].clue[m_currentClue[0]];
             document.getElementById("searchResults").innerHTML="UAV: The object is a "+clueinfo.info+".";
           }
         }
         function getTruth(){
           let clueinfo=m_expsetupobj.location_3D[m_exp_loc_index].clue[m_currentClue[0]];
           document.getElementById("searchResults").innerHTML="Human search team: The object is a "+clueinfo.truth+".";
         }
         function DetectTurningPoint(previousheight){
           let res_turnnpt=0;
           if(m_passPath.length<2){
             return res_turnnpt;
           }
           let direction=[0,0];
           direction[0]=m_passPath[m_passPath.length-2][0]-m_passPath[m_passPath.length-1][0];
           direction[1]=m_passPath[m_passPath.length-2][1]-m_passPath[m_passPath.length-1][1];

           let t_direction=[0,0];
           let t_route=m_UAVRouteHML[previousheight];
           t_direction[0]=m_passPath[m_passPath.length-1][0]-t_route[0][0];
           t_direction[1]=m_passPath[m_passPath.length-1][1]-t_route[0][1];

           //console.log(m_passPath[m_passPath.length-1],t_route[0],direction,t_direction);

           let slop;
           if(Math.abs(direction[0])>0.00000000001){//direction[0]!=0 //
             slop=direction[1]/direction[0];
             //console.log('slop',slop,direction);
             for(let i=1;i<t_route.length;i++){
               res_turnnpt=i;
               if(Math.abs(t_direction[0])<0.00000000001){//t_direction[0]==0
                 //console.log('t_direction',t_direction);
                 break;
               }
               else{
                 let t_slop=t_direction[1]/t_direction[0];
                 //console.log(slop,t_slop,(t_slop-slop)*(t_slop-slop),"square(t_slop-slop)");
                 if((t_slop-slop)*(t_slop-slop)>0.001){
                   //console.log(t_slop,"square(t_slop-slop)");
                   break;
                 }
               }

               t_direction[0]=t_route[i][0]-t_route[i-1][0];
               t_direction[1]=t_route[i][1]-t_route[i-1][1];
               //res_turnnpt=i;
             }
           }
           else{
             for(let i=1;i<t_route.length;i++){
               if(Math.abs(t_direction[0])>0.00000000001){//t_direction[0]!=0
                 //console.log('slop',slop,direction);
                 res_turnnpt=i;
                 break;
               }
               t_direction[0]=t_route[i][0]-t_route[i-1][0];
               t_direction[1]=t_route[i][1]-t_route[i-1][1];
             }
           }
           //console.log("res_turnnpt",res_turnnpt);
           return res_turnnpt;
         }
         function setHeight(height=0){

           /*
           if(m_passPath.length<3){
             return;
           }
           m_currentHeight=height;
           let arr_resolution=[0.0008,0.00055,0.0003];//
           let arr_baseheight=[0,-50,-100];
           let direction=[0,0];
           direction[0]=m_passPath[m_passPath.length-2][0]-m_passPath[m_passPath.length-1][0];
           direction[1]=m_passPath[m_passPath.length-2][1]-m_passPath[m_passPath.length-1][1];
           GetUpdatedPathFromCell3D(m_geometry_2D,m_urlObj,arr_baseheight[m_currentHeight],arr_resolution[m_currentHeight],m_passPath[m_passPath.length-1],direction,m_passPath);
           return;
           */
           let outSpatialReference = new SpatialReference({
             wkid: 4326
           });
           let t_previousHeight=m_currentHeight;
           m_currentHeight=height;
           //console.log(m_currentClue);
           if(m_currentClue === undefined){
             graphicsLayer3D_UAVPath.removeAll();
             let tcolor=Object.values(m_segmentRingColor);
             DrawPath(m_UAVRouteHML[m_currentHeight],tcolor[m_currentHeight],outSpatialReference);
             return;
           }
           if(m_slice_tag){
             if(height==t_previousHeight){
               //this is the most robustic
               m_UAVRouteHML[m_currentHeight] = m_UAVRouteHML[m_currentHeight].slice(m_currentClue[m_currentHeight+1]+1);
               //console.log(m_UAVRouteHML);
             }
             else{
               //console.log(m_UAVRouteHML[t_previousHeight]);
               //console.log(m_passPath);
               m_UAVRouteHML[t_previousHeight] = m_UAVRouteHML[t_previousHeight].slice(m_currentClue[t_previousHeight+1]+1);
               let res_turnnpt=DetectTurningPoint(t_previousHeight);
               //console.log("res_turnnpt",res_turnnpt);
               let t_route=m_UAVRouteHML[t_previousHeight].slice(0,res_turnnpt);// in the middle between t_route and m_UAVRouteHML
               m_UAVRouteHML[t_previousHeight]=m_UAVRouteHML[t_previousHeight].slice(res_turnnpt+1);

               for(let i=0;i<3;++i){
                 if(i==t_previousHeight){
                 }
                 else{
                   CutPassedPath(i,t_route[t_route.length-1]);
                   //console.log(t_route,m_UAVRouteHML[i]);

                   let heightchange=t_route[t_route.length-1][2]-m_UAVRouteHML[i][0][2];
                   //console.log(heightchange,t_route[t_route.length-1][2],m_UAVRouteHML[i][0][2]);

                   let i_route=[];
                   for(let j=0;j<t_route.length;j++){
                     i_route.push([t_route[j][0],t_route[j][1],t_route[j][2]-heightchange]);
                   }
                   m_UAVRouteHML[i]=i_route.concat(m_UAVRouteHML[i]);
                 }
               }
             }
             GetCluePointsOnPath3D();
             m_slice_tag=false;
           }
           graphicsLayer3D_UAVPath.removeAll();
           DrawPath(m_passPath,[80,80,80],outSpatialReference,4);
           let tline=[m_passPath[m_passPath.length-1],m_UAVRouteHML[m_currentHeight][0]];
           DrawPath(tline,[80,80,80],outSpatialReference,4);
           let tcolor=Object.values(m_segmentRingColor);
           DrawPath(m_UAVRouteHML[m_currentHeight],tcolor[m_currentHeight],outSpatialReference);
           //console.log(m_unfoundClues);
         }
         document.getElementById("sel_lpm").onchange=function(){

           m_lpdata_con=[];
           m_lpdata_trial=[];
           m_lpdata_trajectory=[];
           m_lpdata_tra_colormap=[];

           ClearAll();
           document.getElementById("loadlpmcsv").value="Load LPM Data";
           DisableAllGraphicLayers();
           m_lostpersontype_index=document.getElementById("sel_lpm").selectedIndex;
         }
         document.getElementById("sel_rank").onchange=function(){

             m_experimentres["visualization_type"]=document.getElementById("sel_lpmodel").value;
             m_experimentres["actions"].push({"id":"sel_lpmodel","timestamp": Date.now(), "description":m_experimentres["visualization_type"]});
             DisableAllGraphicLayers();
             UpdateVisualization();
         }

          document.getElementById("sel_lpmodel").onchange=function(){

            m_experimentres["visualization_type"]=document.getElementById("sel_lpmodel").value;
            m_experimentres["actions"].push({"id":"sel_lpmodel","timestamp": Date.now(), "description":m_experimentres["visualization_type"]});
            DisableAllGraphicLayers();
            UpdateVisualization();
          }

         document.getElementById("myRange").onchange=function(){
           //console.log("change");
           m_experimentres["actions"].push({"id":"myRange","timestamp": Date.now(), "description":"Change hour to "+document.getElementById("myRange").value.toString()});
           let t_hour=parseInt(document.getElementById("myRange").value)+1;
            $("#lmyRange").text("Hour(1-12): "+t_hour);
            SetTargetpolygon();
           UpdateVisualization();
         }

         document.getElementById("myClues").onchange=function(){
           //console.log("change");
           m_experimentres["actions"].push({"id":"myClues","timestamp": Date.now(), "description":"Change hour to "+document.getElementById("myClues").value.toString()});
           let t_clue=parseInt(document.getElementById("myClues").value);
            //$("#lmyClues").text("Clue(0-3): "+t_clue);
           UpdateVisualization();
         }

         document.getElementById("sel_ic").onchange=function(){
           ClearAll();
           m_scenario_index=document.getElementById("sel_ic").selectedIndex;
           view.goTo([ m_scenarios[m_scenario_index]['center'] ]);

           m_lpdata_con=[];
           m_lpdata_trial=[];

           m_lpdata_trajectory=[];
           m_lpdata_tra_colormap=[];

           document.getElementById("loadlpmcsv").value="Load LPM Data";
           DisableAllGraphicLayers();

         }

         document.getElementById("sel_colormap").onchange=function(){

             m_experimentres["visualization_type"]=document.getElementById("sel_lpmodel").value;
             m_experimentres["actions"].push({"id":"sel_colormap","timestamp": Date.now(), "description":m_experimentres["visualization_type"]});

             //console.log(m_experimentres);
             DisableAllGraphicLayers();
             UpdateVisualization();
         }
         //--------------------------------------------------
           document.getElementById("lpmmodeldisplay").onclick=function() {
             m_experimentres["actions"].push({"id":"lpmmodeldisplay","timestamp": Date.now(), "description":"diplay model"});
             DisableAllGraphicLayers();
             UpdateVisualization();
           }

         document.getElementById('visualizationtype').addEventListener('click',function(){
           if(document.getElementById("visualizationtype").checked){
             m_visualizationtype='byclue';
           }
           else{
             m_visualizationtype='byhour';
           }
         });

         document.getElementById("lpinfo").onclick=function() {
           DisplayLostPersonInfo();
           m_experimentres["actions"].push({"id":"lpinfo","timestamp": Date.now(), "description":"display lost person information"});
         }

         document.getElementById("bt_generatetask").onclick=function() {
           TaskGenerateArea_2D_3D();
         }

         document.getElementById("bt_getcameraposition").addEventListener("click",function(){
            //console.log(view3D.camera);

            let x=view3D.camera.position.longitude-m_exp_location.center[0];
            let y=view3D.camera.position.latitude-m_exp_location.center[1];
            console.log("camera x:",x.toString(), " , y:", y.toString(),"camera:",view3D.camera);

         });
         document.getElementById("bt_getareasegment").addEventListener("click",function(){
           LoadLPMData();
         });
         document.getElementById("bt_getpath").addEventListener("click",function(){
           m_step=0;
           DisplayUAVPath_3D();
         });
         $('#myRangeTrust').on('change', function() {
              document.getElementById("myRangeTrustAmount").innerHTML =  document.getElementById("myRangeTrust").value;
          });

         document.getElementById("bt_updateuavpostion").addEventListener("click",function(){

           if(m_DroneUpdate3D && !m_searchFinish){
             //document.getElementById("bt_updateuavpostion").value='Stop';
             document.getElementById("bt_updateuavpostion").innerHTML='Stop';
             timerid3d=setInterval(UpdateDroneLocationTimer3D,50);///300
             m_DroneUpdate3D=false;
             m_slice_tag=true;
             m_trialindex=m_trialindex+1;
           }
           else{
             clearInterval(timerid3d);
             //document.getElementById("bt_updateuavpostion").value='Search';
             document.getElementById("bt_updateuavpostion").innerHTML='Search';
             m_DroneUpdate3D=true;
           }

         });
         document.getElementById("bt_raiseUAVPath").addEventListener("click",function(){
           raiseUAVPath_3D();
         });
         document.getElementById("bt_lowerUAVPath").addEventListener("click",function(){
           lowerUAVPath3D();
         });
         document.getElementById("bt_sendHumanSearchTeam").addEventListener("click",function(){
           getTruth();
         });
         document.getElementById("bt_UAVH").addEventListener("click",function(){
           m_step=0;// to new step from m_UAVRouteHML[L,M,H]
           setHeight(0);
         });
         document.getElementById("bt_UAVM").addEventListener("click",function(){
           m_step=0;
           setHeight(1);
         });
         document.getElementById("bt_UAVL").addEventListener("click",function(){
           m_step=0;
           setHeight(2);
         });

         document.getElementById("bt_getheatmap").addEventListener("click",function(){
           // set all parameters: location, type of lost person
           //console.log(m_lpdata_con);
            DisplayHeatmap();
            DisplayHeatmap_3D();
         });
         document.getElementById("clueConfirm").onclick=function() {
           document.getElementById("testImg").src="{% static 'img/UAVClueDemo.png' %}";
           let ele = document.getElementsByName('detectedClue');
           for(i = 0; i < ele.length; i++) {
               if(ele[i].checked){
                 document.getElementById("detectedClueRes").innerHTML = "You selected: "+ele[i].value;
                 let res_trust=document.getElementById("myRangeTrust").value;
                 if(m_currentClue.length>0){
                   m_expResults.BPJudge.push({"currentClue":m_expsetupobj.location_3D[m_exp_loc_index].clue[m_currentClue[0]],"trial":m_trialindex,"pObject":ele[i].value,"pTrust":res_trust});
                 }
                 else{
                   m_expResults.BPJudge.push({"currentClue":NA,"trial":m_trialindex,"pObject":ele[i].value,"pTrust":res_trust});
                 }
                 //console.log(m_expResults);
               }
           }
           if(ele[0].checked){
             let clueinfo=m_expsetupobj.location_3D[m_exp_loc_index].clue[m_currentClue[0]];
             document.getElementById("searchResults").innerHTML="Human rescue team: The object is a "+clueinfo.truth+".";
           }
           for(i = 0; i < ele.length; i++) {
             ele[i].checked=false;
           }

         }
         document.getElementById("btnshowhideexptoolpannel").onclick=function() {
             if(document.getElementById("btnshowhideexptoolpannel").value=='E'){
                 document.getElementById("toolpannel").style.display="block";
                 document.getElementById("btnshowhideexptoolpannel").value='H';
             }
             else{
                 document.getElementById("toolpannel").style.display="none";
                 document.getElementById("btnshowhideexptoolpannel").value='E';
             }
         }
         document.getElementById("btndisplaytarget").onclick=function() {
           DrawToTemperalGraphicLayer(m_exp_location.target,type="point");
           //DisplayClue_3D(m_exp_location.target, m_exp_location.clue,type="point");
           //console.log(m_exp_location.target);
           //console.log(m_expsetupobj.location_3D[m_exp_loc_index]);

           DisplayAllClue_3D(m_expsetupobj.location_3D[m_exp_loc_index]);
         }
         document.getElementById("btskipback").onclick=function() {

           participant_avata.experimentsetup=participant_avata.experimentsetup-1;

           ClearAll();
           m_exp_loc_index=m_expsetupobj.experimentsetup[participant_avata.experimentsetup].loc;
           m_exp_visualizationtype_index=m_expsetupobj.experimentsetup[participant_avata.experimentsetup].vt;
           m_exp_location=m_expsetupobj.location[m_exp_loc_index];
           view3D.goTo({
               center:[m_exp_location.center[0]+m_exp_location.offset[0],m_exp_location.center[1]+m_exp_location.offset[1]]//[m_exp_location.center],
           });
           view.goTo({
               center:[m_exp_location.center[0]+m_exp_location.offset[0],m_exp_location.center[1]+m_exp_location.offset[1]]//[m_exp_location.center],
           });
           document.getElementById("btic").value=m_exp_location.name;
         }
         document.getElementById("q_scene").onclick=function() {
            let participantid={{ participantid |safe }};
            let task_url="{% url 'questionnaireform3D' %}"+"/"+participantid+'/'+participant_avata.experimentindex.toString()+'/'+m_exp_order.toString()+'/';

            let win = window.open(task_url, '_blank');
            win.focus();
         }
         document.getElementById("bt_scenario").onclick=function() {
           m_exp_order=m_exp_order+1;
           console.log(m_exp_order);
         }


         document.getElementById("btskip").onclick=function() {
           participant_avata.experimentsetup=participant_avata.experimentsetup+1;

           ClearAll();
           m_exp_loc_index=m_expsetupobj.experimentsetup[participant_avata.experimentsetup].loc;
           m_exp_visualizationtype_index=m_expsetupobj.experimentsetup[participant_avata.experimentsetup].vt;
           m_exp_location=m_expsetupobj.location[m_exp_loc_index];
           view3D.goTo({
               center:[m_exp_location.center[0]+m_exp_location.offset[0],m_exp_location.center[1]+m_exp_location.offset[1]]//[m_exp_location.center],
           });
           view.goTo({
               center:[m_exp_location.center[0]+m_exp_location.offset[0],m_exp_location.center[1]+m_exp_location.offset[1]]//[m_exp_location.center],

           });
           document.getElementById("btic").value=m_exp_location.name;
         }
         document.getElementById('view_x2d').addEventListener('click',function(){
           location.href = "/";
         });

        $("#flip1").click(function(){
          $("#panel1").slideToggle("slow");
        });
        $("#flip2").click(function(){
          $("#panel2").slideToggle("slow");
        });
        $("#flip3").click(function(){
          $("#panel3").slideToggle("slow");
        });

      //--------------------------------------------------
    });


  </script>
</head>

<body>
  <div class="viewContainer">
    <div class="InfoDiv">
      <div id="viewDiv2D"></div>
      <div id="questionPerTrial">
        <p id="infocontent">LPM Data</p>
        <img id="testImg" src="{% static 'img/UAVClueDemo.png' %}" alt="test" width="300" height="200">
        <p id="searchResults">Search results: NA</p>
        <p>The detected object is:</p>
        <input type="radio" name="detectedClue" value="Target" >Target<br>
        <input type="radio" name="detectedClue" value="Clue" >Clue<br>
        <input type="radio" name="detectedClue" value="Distractor" >Distractor<br>
        <div class="slidecontainer">
          <p>How much do you trust the height recommendation?</p>
          <input type="range" min="1" max="100" value="50" id="myRangeTrust">
          <label id="myRangeTrustAmount">50</label>
        </div>
        <label for="clueConfirm" id="detectedClueRes" style="display:none">You selected: NA</label>
        <button class="bt_screen" id="clueConfirm">Confirm</button>
        <button class="bt_screen" id="q_scene">Questionnaire</button>
        <button class="bt_screen" id="bt_scenario">Next Scenario</button>
      </div>
    </div>
    <div class="mapDiv">
      <div id="viewDiv3D"></div>
      <div class="bottom_screen">
        <div>
          <label class="lb_screen">Task Control:</label>
          <button class="bt_screen" id="bt_getareasegment">Load LPM Data</button>
          <button class="bt_screen" id="bt_generatetask">Generat Task</button>
          <button class="bt_screen" id="bt_getheatmap">Get Heat Map</button>
          <button class="bt_screen" id="bt_getpath">Get 3D Path</button>
          <button class="bt_screen" id="bt_getcameraposition">Get Camera</button>
        </div>

        <div>
          <label class="lb_screen">Search Control:</label>
          <button class="bt_screen" id="bt_updateuavpostion">Search</button>
          <button class="bt_screen" id="bt_lowerUAVPath">Lower UAV</button>
          <button class="bt_screen" id="bt_raiseUAVPath">Raise UAV</button>
          <button class="bt_screen" id="bt_sendHumanSearchTeam">Send Human Search Team</button>
        </div>

        <div>
          <label class="lb_screen">Path Planning:</label>
          <button class="bt_screen" id="bt_UAVH">Set UAV Path: High</button>
          <button class="bt_screen" id="bt_UAVM">Set UAV Path: Medium</button>
          <button class="bt_screen" id="bt_UAVL">Set UAV Path: Low</button>
        </div>

      </div>

      <div id="showtarget">
          <input type="button" id="btnshowhideexptoolpannel" value="E"/>
          <div id="toolpannel" style="display:none">
              <input type="button" id="btndisplaytarget" value="T"/>
              <br>
              <input type="button" id="btskipback" value="<"/>
              <br>
              <input type="button" id="btskip" value=">"/>
              <br>
              <input type="button" id="btic" value="ic"/>
          </div>
      </div>

      <div id="map2Dvs3D">
      	<button id="view_x2d">2D</button>
      </div>

    </div>
  </div>

  <div id="editArea" class="editArea-container">
    <h2 class="list-heading">Search & Rescue Tools</h2>

    <div id="flip1" class="flip">Map Division</div>
    <div id="panel1" style="display:none">
      <h3 class="list-heading">Map Division</h3>
      <div>
        <label >Load a scene: </label>
        <select id="sel_ic">
          <option value="0">Scene 1</option>
          <option value="1">Scene 2</option>
          <option value="2">Scene 3</option>
        </select>
        <input type="button" id="label_ic" value="Load" style="display:none"></input>
      </div>

      <div>
        <label >Lost person type: </label>
        <select id="sel_lpm">
          <option value="child10to12">Child</option>
          <option value="dementia">Dementia</option>
          <option value="hiker" selected>Hiker</option>

        </select>
        <input type="button" id="label_lpt" value="Switch" style="display:none"></input>
      </div>

      <div>
        <input type="button" class="edit-button" value="Load LPM Data" id="loadlpmcsv">
      </div>

      <!--div><input type="checkbox" name="voronoi" class="check" value="random"> Random Voronoi</input></div-->
      <!--div><input type="checkbox" name="voronoi" class="check" value="triangle"> Triangle based on vertices</input></div-->
      <!--div><input type="checkbox" name="voronoi" class="check" value="clear"> Freehand Polygon</input></div-->

      <input type="button" class="edit-button" value="Generate task" id="btngeneratearea"/>
      <input type="button" class="edit-button" value="Edit cells" id="btneditcells" style="display:none"/>

      <div  style="display:none">
        <input type="text" class="bt_save_edit" id="tasknotes" value="Task_name"></input>
        <input type="button" class="bt_save" value="Save Task" id="savetasks"></input>
      </div>
    </div>

    <hr/>
    <div id="flip2" class="flip">Lost person model</div>
      <div id="panel2" style="display:none">
      <div>
        <label id="colormap">Color map: </label>
        <select id="sel_colormap" class="sel_options">
          <option value="o_rainbow">Rainbow</option>
          <option value="o_yr">Yellow-red</option>
          <option value="o_br">Blue-red</option>
        </select>
        <input type="button" id="colormap" value="Switch" style="display:none"></input>

      </div>

      <div>
        <label >Model best fit: </label>
        <select id="sel_rank">
          <option value="1">bf1</option>
          <option value="2">bf2</option>
          <option value="3">bf3</option>
        </select>
        <input type="button" id="label_rank" value="Switch" style="display:none"></input>
      </div>

      <div class="slidecontainer">
        <label for="myRange" id="lmyRange">Hour(1-12): 1</label>
        <input type="range" min="0" max="11" value="0" class="slider" id="myRange">

      </div>
      <div class="slidecontainer">
        <label for="myClues" id="lmyClue">Clue(0-3): 0</label>
        <input type="range" min="0" max="3" value="0" class="slider" id="myClues">
      </div>

      <div>
        <select id="sel_lpmodel">
          <option value="clueipp">IPP & Rings</option>
          <option value="contour">Contour map</option>
          <option value="trajectories">Trajectories</option>
          <option value="cone">Cone</option>
          <option value="segmentheat">Segment heat</option>
        </select>
        <input type="button" id="lpmmodeldisplay" value="Display" disabled></input>
        <input type="checkbox" id="displaytype" name="displaytype" value="byhour">
        <label for="displaytype">Groupbyhr</label>
      </div>
    </div>
    <hr/>
    <div id="flip3" class="flip">Task Assignment</div>
    <div id="panel3" style="display:none">

      <hr>
      <div id="draw">
        <h3 class="list-heading">Map measurement tools</h3>
        <div><input type="button" class="edit-button" value="Measure distance" id="distanceButton"></input></div>
        <div><input type="button" class="edit-button" value="Measure area" id="areaButton"></input></div>
      </div>
      <div>
        <input type="button" class="edit-button" value="Display Lost Person Info" id="lpinfo">
        <input type="checkbox" id="visualizationtype" name="visualizationtype" value="byhour">
        <label for="visualizationtype">Filter data by clue(none,1,2,12)</label>
        <input type="button"  class="edit-button" id="btndisplaytarget" value="Show Target"></input>
        <input type="button" class="edit-button" value="Clear All" id="clearall"></input>
      </div>
    </div>

  </div>

</body>
</html>
